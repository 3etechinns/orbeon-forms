<!--
    Copyright (C) 2004 Orbeon, Inc.

    The Orbeon documentation is not distributed under the LGPL license. Use of the documentation is
    subject to the following terms:

    * Conversion to other formats is allowed, but the actual content may not be altered or edited
      in any way.

    * You may create printed copies for your own personal use.

    * For all other uses, such as selling printed copies or using (parts of) the manual in another
      publication, prior written agreement from Orbeon, Inc. is required.

    Please contact Orbeon at info@orbeon.com for more information.
-->
<document xmlns:p="http://www.orbeon.com/oxf/pipeline"
          xmlns:xforms="http://www.w3.org/2002/xforms">
    <header>
        <title>SQL Processor</title>
    </header>
    <body>
        <section>
            <title>Introduction</title>
            <p>
                The SQL processor provides an XML interface to any SQL database accessible through
                JDBC. It allows to easily query databases and produce XML outputs readily usable
                by other processors. Conversely, the SQL processor allows to perform updates,
                insertions and deletions from XML data generated by other processors.
            </p>
        </section>
        <section>
            <title>Inputs and Outputs</title>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Name</th>
                    <th>Purpose</th>
                    <th>Mandatory</th>
                </tr>
                <tr>
                    <td align="center">Input</td>
                    <td><code>config</code></td>
                    <td>Configuration in XML-SQL</td>
                    <td align="center">Yes</td>
                </tr>
                <tr>
                    <td align="center">Input</td>
                    <td><code>data</code></td>
                    <td>Source XML data</td>
                    <td align="center">No</td>
                </tr>
                <tr>
                    <td align="center">Input</td>
                    <td><code>datasource</code></td>
                    <td>Datasource configuration</td>
                    <td align="center">No</td>
                </tr>
                <tr>
                    <td align="center">Output</td>
                    <td><code>data</code></td>
                    <td>Result XML data</td>
                    <td align="center">No</td>
                </tr>
            </table>
            <p>
                If the <code>data</code> input is not connected, the SQL processor configuration
                must not use XPath expressions operating on it. If this condition is not satisfied,
                the SQL processor generates an error at runtime. It is typically useful to omit the
                <code>data</code> input when the SQL processor only reads data from the database and
                generates an output XML document.
            </p>
            <p>
                If the <code>data</code> output is not connected, the output of the SQL processor is
                simply ignored. It is typically useful to omit the <code>data</code> output when the
                SQL processor only updates or insert data into the database from an input XML
                document.
            </p>
        </section>
        <section>
            <title>XML-SQL</title>
            <section>
                <title>Configuration</title>
                <p>
                    XML-SQL is a simple set of XML tags that allow you to integrate SQL queries and
                    XML. XML-SQL lives in the <code>http://orbeon.org/oxf/xml/sql</code> namespace,
                    which is usually mapped to the <code>sql</code> prefix. An XML-SQL configuration
                    input has the following format:
                </p>
                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <comment>Optional user content</comment>
    <sql:connection>
        <comment> Datasource name (can also be specified with optional "datasource" input) </comment>
        <sql:datasource>my-datasource</sql:datasource>
        <comment>...</comment>
    </sql:connection>
    <comment>Optional user content</comment>
</sql:config>
                </xml-source>
                <p>
                    The <code>sql:datasource</code> element specifies a datasource name under
                    <code>java:comp/env/jdbc</code>. In the example above, the datasource named
                    <code>my-datasource</code> is used. How the datasource is configured depends on
                    the application server used. Please refer to the documentation of your
                    application server for more information.
                </p>
                <p>
                    Alternatively, the <code>sql:datasource</code> element can be omitted. In that
                    case, the <code>datasource</code> input of the SQL processor must be connected
                    to an external datasource definition, which describes database connections
                    without using JNDI names mapped by the container. This is an example of
                    datasource definition:
                </p>
                <xml-source>
                    <datasource>
                        <comment> Specify the driver for the database </comment>
                        <driver-class-name>org.hsqldb.jdbcDriver</driver-class-name>
                        <comment> This causes the use of the embedded database </comment>
                        <uri>jdbc:hsqldb:file:orbeondb</uri>
                        <comment> Optional username and password </comment>
                        <username>sa</username>
                        <password></password>
                    </datasource>
                </xml-source>
                <warning>
                    External datasource definitions do not use connection pooling at the moment.
                    Because creating database connections is usually an expensive operation, they
                    should be used only for development or demo purposes.
                </warning>
                <p>
                    The <code>sql:config</code> element can contain any number of user-defined
                    content before and after the <code>sql:connection</code> element.
                </p>
            </section>
            <section>
                <title>sql:execute</title>

                <p>The <code>sql:execute</code> element controls the execution of a single
                SQL query or update (update, insert or delete). It must start with either
                a <code>sql:query</code> or a <code>sql:update</code> element, which contains
                the SQL to execute. <code>sql:query</code> can
                be followed by <code>sql:results</code>, <code>sql:no-results</code> or
                both elements. Any number of <code>sql:execute</code> elements can be used
                in order to execute several queries or updates within a single connection
                declaration.</p>

                <xml-source>
<comment>Optional user content</comment>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:query>
        <comment>...</comment>
    </sql:query>
    <comment>Optional user content</comment>
    <sql:results>
        <comment>...</comment>
    </sql:results>
    <sql:no-results>
        <comment>...</comment>
    </sql:no-results>
</sql:execute>
<comment>Optional user content</comment>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        <comment>...</comment>
    </sql:update>
</sql:execute>
<comment>Optional user content</comment>
                </xml-source>

            </section>

            <section>
                <title>sql:query and sql:update</title>

                <p><code>sql:query</code> and <code>sql:update</code> encapsulate SQL
                statements. Like in JDBC, a distinction is made between queries (SQL
                <code>select</code>) and updates (SQL <code>update</code>, <code>insert</code>
                and <code>delete</code>):</p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
  select * from employee
</sql:query>
                </xml-source>

                <xml-source>
<sql:update xmlns:sql="http://orbeon.org/oxf/xml/sql">
  insert into employees values ('John', 'Doe')
</sql:update>
                </xml-source>

                <p>
                    It is possible to pass parameters to a query using the <code>sql:param</code>
                    element. <code>sql:param</code> requires a <code>type</code> attribute that
                    specifies the type of the parameter to set. The type system is borrowed from the
                    <a href="http://www.w3.org/TR/xmlschema-2/">XML Schema Part 2: Datatypes</a>
                    specification. The following types are supported:
                </p>

                <ul>
                    <li><code>xs:string</code></li>
                    <li><code>xs:int</code></li>
                    <li><code>xs:boolean</code></li>
                    <li><code>xs:decimal</code></li>
                    <li><code>xs:float</code></li>
                    <li><code>xs:double</code></li>
                    <li><code>xs:dateTime</code></li>
                    <li><code>xs:date</code></li>
                    <li><code>xs:base64Binary</code></li>
                    <li><code>oxf:xmlFragment</code></li>
                </ul>

                <p>
                    <code>xs:date</code> and <code>xs:dateTime</code> should be
                    in one of the following formats:
                </p>

                <ul>
                    <li><code>CCYY-MM-DDThh:mm:ss.sss</code></li>
                    <li><code>CCYY-MM-DDThh:mm:ss</code></li>
                    <li><code>CCYY-MM-DD</code></li>
                </ul>

                <p>
                    Unless a getter is nested in the <code>sql:param</code> element (see the section
                    about nested queries below), a <code>select</code> attribute is mandatory. Its
                    content is evaluated as an XPath expression against the input XML document:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
select first_name, last_name
  from employee
 where employee_id in (<sql:param type="xs:int" select="/query/employee-id[1]"/>,
                       <sql:param type="xs:int" select="/query/employee-id[2]"/>)
</sql:query>
                </xml-source>

                <p>Any number of <code>sql:param</code> elements may be used.</p>

                <p>
                    <code>sql:param</code> supports an optional boolean <code>replace</code>
                    attribute, that can take the value <code>true</code> or <code>false</code> (the
                    default). When <code>replace</code> is set to <code>true</code>, the parameter
                    is simply replaced in the query, instead of being set on a JDBC
                    <code>PreparedStatement</code>. This however works only with the
                    <code>xs:int</code> and <code>oxf:literalString</code> types. This attribute is
                    useful to dynamically generate parts of SQL queries, or to set parameters that
                    do not allow being set via JDBC's <code>setYyy</code> methods. For example,
                    with SQL Server:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
    select top&#160;<sql:param type="xs:int" select="/query/max-rows" replace="true"/>&#160;*
      from employee
</sql:query>
                </xml-source>

                <p>
                    <code>sql:param</code> supports an optional <code>separator</code> attribute.
                    When that attribute is present, the result of the XPath expression in the
                    <code>select</code> attribute is interpreted as a node-set. One query parameter
                    is set for each element in the node set, separated by the characters in the
                    separator. For example:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
   select * from book
    where book_id in (<sql:param type="xs:int" select="/query/book-id" separator=","/>)
</sql:query>
                </xml-source>

                <p>
                    Assuming the input document contains:
                </p>

                <xml-source>
<query>
    <book-id>5</book-id>
    <book-id>7</book-id>
    <book-id>11</book-id>
    <book-id>13</book-id>
</query>
                </xml-source>

                <p>
                    The following equivalent query will be executed:
                </p>

                <xml-source>
<sql:query xmlns:sql="http://orbeon.org/oxf/xml/sql">
   select * from book
    where book_id in (5, 7, 11, 13)
</sql:query>
                </xml-source>

            </section>

            <section>
                <title>Root Element</title>

                <p>
                    It is important to make sure that one and exactly one root element is output by
                    the SQL processor. A good place to put such a root element is around the
                    <code>sql:connection</code> element:
                </p>

                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <employees>
        <sql:connection>
            <comment>...</comment>
        </sql:connection>
    </employees>
</sql:config>
                </xml-source>

            </section>

            <section>
                <title>sql:results and sql:no-results</title>

                <p>These elements must be used only in conjunction with <code>sql:query</code>.
                When a query return at least one row, the subsequent <code>sql:results</code>
                is evaluated. When no row is returned, <code>sql:no-results</code> is evaluated.</p>

                <p><code>sql:results</code> must contain a
                <code>sql:row-results</code> element, which is evaluated once
                for every row of the result set. <code>sql:row-results</code>
                typically contains user-defined content, as well as column
                getters such as <code>sql:get-column</code> and
                <code>sql:get-columns</code>.</p>

                 <xml-source>
<sql:results xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:row-results>
        <employee>
            <first-name><sql:get-column type="xs:string" column="first_name"/></first-name>
            <last-name><sql:get-column type="xs:string" column="last_name"/></last-name>
        </employee>
    </sql:row-results>
</sql:results>
                </xml-source>

                <p>Assuming the result set contains two rows with "John Doe" and "Billy Smith",
                the above code produces the following XML fragment:</p>

                 <xml-source>
<employee>
    <first-name>John</first-name>
    <last-name>Doe</last-name>
</employee>
<employee>
    <first-name>Billy</first-name>
    <last-name>Smith</last-name>
</employee>
                </xml-source>

            </section>

            <section>
                <title>Getting Column Values</title>

                <p>
                    You can get column values with the
                    <code>sql:get-column</code> and
                    <code>sql:get-columns</code> elements.
                </p>

                <p>
                    <code>sql:get-column</code> takes a mandatory
                    <code>column</code> attribute and a mandatory
                    <code>type</code> attribute. The type system is borrowed
                    from the <a href="http://www.w3.org/TR/xmlschema-2/">XML
                    Schema Part 2: Datatypes</a> specification. The following
                    types are supported:
                </p>

                <ul>
                    <li><code>xs:string</code></li>
                    <li><code>xs:int</code></li>
                    <li><code>xs:boolean</code></li>
                    <li><code>xs:decimal</code></li>
                    <li><code>xs:float</code></li>
                    <li><code>xs:double</code></li>
                    <li><code>xs:dateTime</code></li>
                    <li><code>xs:date</code></li>
                    <li><code>xs:base64Binary</code></li>
                    <li><code>oxf:xmlFragment</code></li>
                </ul>

                <p>
                    <code>xs:dateTime</code> returns a date in the following format:
                    <code>CCYY-MM-DDThh:mm:ss.sss</code>.
                </p>

                <p>
                    <code>xs:date</code> returns a date in the following format:
                    <code>CCYY-MM-DD</code>.
                </p>

                <p>
                    <code>oxf:xmlFragment</code> is a special type that gets the column as a
                    string, parses it as an XML fragment, and embeds the resulting XML in the SQL
                    processor output.
                </p>

                <note>
                    For compatibility with XPath 1.0, <code>xs:float</code> and
                    <code>xs:double</code> do not return values in the exponential notation. For
                    example, instead of <code>1.2E10</code>, <code>12000000000</code> is returned.
                </note>

                <p>
                    When the number of columns returned is large, it is convenient to use
                    <code>sql:get-columns</code>, which automatically determines what columns are
                    available and generates elements accordingly. <code>sql:get-columns</code> takes
                    an optional <code>prefix</code> attribute specifying the output namespace prefix
                    to use for all the elements, and an optional <code>format</code> attribute
                    specifying how column names are converted. It also supports any number of
                    embedded <code>exclude</code> elements that specify columns to exclude from the
                    result.
                </p>

                <p>
                    <code>sql:get-columns</code> supports an <code>all-elements</code> attribute.
                    If set to <code>true</code>, an element is output for a column even if that
                    column returns a null value. If missing or set to <code>false</code>, no element
                    is output for a null column.
                </p>

                <p>
                    The namespace prefix, if specified, must have been mapped to a namespace URI.
                </p>

                <p>
                    If no format is specified, the original column names are used. Specifying the
                    <code>xml</code> format converts all column names to lower case and transforms
                    "_" into "-".
                </p>

                <p>The example below generates the same results as above:</p>

                <xml-source>
<sql:results xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:row-results>
        <employee>
            <sql:get-columns format="xml"/>
        </employee>
    </sql:row-results>
</sql:results>
                </xml-source>

                <p>
                    Not specifying the <code>xml</code> format generates the
                    following results:
                </p>

                <xml-source>
<employee>
    <first_name>John</first_name>
    <last_name>Doe</last_name>
</employee>
<employee>
    <first_name>Billy</first_name>
    <last_name>Smith</last_name>
</employee>
                </xml-source>

                <p>
                    It is possible to exclude the <code>first_name</code> column
                    as follows:
                </p>

                <xml-source>
<sql:results xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:row-results>
        <employee>
            <sql:get-columns format="xml">
                <sql:exclude>first_name</sql:exclude>
            </sql:get-columns>
        </employee>
    </sql:row-results>
</sql:results>
                </xml-source>

                <p>
                    This generates the following results:
                </p>

                <xml-source>
<employee>
    <last_name>Doe</last_name>
</employee>
<employee>
    <last_name>Smith</last_name>
</employee>
                </xml-source>

                <p>When no rows are returned, the content of the <code>sql:results</code> element
                is completely ignored. Instead, <code>sql:no-results</code> is evaluated.
                <code>sql:no-results</code> may contain user-defined elements and nested queries
                (see below).</p>

            </section>

            <section>
                <title>Specifying a SQL Type</title>

                <p>
                    When setting a parameter of type <code>xs:string</code> or
                    <code>oxf:xmlFragment</code>, it is possible to specify an additional attribute
                    on <code>sql:param</code>: <code>sql-type</code>. By default, text is written
                    using the JDBC setString() method. In case the data must be stored in the
                    database as a Character Large OBject (CLOB) or other database-specific types,
                    it is necessary to tell PresentationServer that a different API must be used. For example, to
                    write a string into a CLOB:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_clob_table (clob_column)
        values (<sql:param select="/document/text" type="xs:string" sql-type="clob"/>)
    </sql:update>
</sql:execute>
                </xml-source>

                <p>
                    The same string can be written as a regular <code>varchar</code> type as
                    follows:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_table (varchar_column)
        values (<sql:param select="/document/text" type="xs:string" sql-type="varchar"/>)
    </sql:update>
</sql:execute>
                </xml-source>

                <p>
                    <code>varchar</code> is actually the default, so you can simply omit the
                    <code>sql-type</code> and write:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_table (varchar_column)
        values (<sql:param select="/document/text" type="xs:string"/>)
    </sql:update>
</sql:execute>
                </xml-source>

                <note>
                    The disadvantage of using database columns of type <code>varchar</code> is that
                    those are severely limited in size, for example 4000 bytes in the case of Oracle
                    9. The maximum size of CLOB columns is usually much larger, for example up to 4
                    GB with Oracle 9. In order to store large strings or large XML documents, it is
                    therefore necessary to use the CLOB type.
                </note>

                <p>
                    The following values are supported for <code>sql-type</code>:
                </p>

                <ul>
                    <li><code>varchar</code> (the default)</li>
                    <li><code>clob</code></li>
                    <li><code>xmltype</code> (see Reading and Writing XML Documents below)</li>
                </ul>

                <warning>
                    <p>
                        Using the <code>clob</code> and <code>xmltype</code> SQL types is currently
                        only supported with the following application server / database
                        combinations:
                    </p>

                    <ul>
                        <li>Tomcat 4.1 and Oracle 9</li>
                        <li>WebLogic 8.1 and Oracle 9</li>
                    </ul>

                    <p>
                        Please <a href="mailto:info@orbeon.com">contact Orbeon</a> to inquire about
                        supporting additional systems.
                    </p>
                    <p>
                        Reading from CLOB columns on the other hand is supported with all JDBC
                        drivers that support the CLOB API.
                    </p>
                </warning>

            </section>

            <section>
                <title>Reading and Writing XML Documents</title>

                <p>
                    As explained in the section about <code>sql-type</code> above, when text data,
                    in particular XML data, is large, it is best stored as a CLOB type or, in the
                    case of XML, as a native database XML data type such as the Oracle
                    <code>XMLType</code> data type.
                </p>

                <p>
                    Reading and writing XML data is supported to and from database CLOBs and, with
                    Oracle 9, to and from <code>XMLType</code>. The <code>oxf:xmlFragment</code>
                    type must be used. To write XML data to a CLOB, use the
                    <code>oxf:xmlFragment</code> type as follows:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_clob_table (clob_column)
        values (<sql:param select="/*" type="oxf:xmlFragment" sql-type="clob"/>)
    </sql:update>
</sql:execute>
                </xml-source>

                <p>
                    The XPath expression must return one element node. The result of the XPath
                    expression specified in the <code>select</code> attribute is converted into a
                    new XML document having as root element the selected element node. The document
                    is then serialized to a character stream and stored as a CLOB.
                </p>

                <p>
                    To read a document from a CLOB column, use the <code>oxf:xmlFragment</code>
                    type as follows:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:query>
        select clob_column from test_clob_table
    </sql:query>
    <sql:results>
        <rows>
            <sql:row-results>
                <row>
                    <sql:get-column type="oxf:xmlFragment" column="clob_column"/>
                </row>
            </sql:row-results>
        </rows>
    </sql:results>
</sql:execute>
                </xml-source>

                <p>
                    For each row returned, the character data stored in the CLOB column is read as
                    text and parsed into an XML fragment. The fragment must be well-formed,
                    otherwise an exception is thrown. The resulting fragment is then embedded into
                    the SQL processor output.
                </p>

                <p>
                    With Oracle 9, it is also possible to write to the native Oracle
                    <code>XMLType</code> data type:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_xmltype_table (xmltype_column)
        values (<sql:param select="/*" type="oxf:xmlFragment" sql-type="xmltype"/>)
    </sql:update>
</sql:execute>
                </xml-source>

                <note>
                    The benefit of using the Oracle <code>XMLType</code> data type is that XML is
                    stored in a structured way in the database. This allows creating indexes on XML
                    data, doing partial document updates, etc. This however requires creating an XML
                    schema. For more information, please refer to the <a
                    href="http://download-west.oracle.com/docs/cd/B10501_01/appdev.920/a96620/toc.htm">Oracle
                    XML DB Developer's Guide</a>.
                </note>

                <p>
                    Reading from an <code>XMLType</code> column is done the same way as with a CLOB
                    column:
                </p>

                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:query>
        select xmltype_column from test_xmltype_table
    </sql:query>
    <sql:results>
        <rows>
            <sql:row-results>
                <row>
                    <sql:get-column type="oxf:xmlFragment" column="xmltype_column"/>
                </row>
            </sql:row-results>
        </rows>
    </sql:results>
</sql:execute>
                </xml-source>

                <warning>
                    <p>
                        Writing to CLOB columns, as well as writing and reading to and from
                        <code>XMLType</code> columns, is currently only supported with the
                        following application server / database combinations:
                    </p>

                    <ul>
                        <li>Tomcat 4.1 and Oracle 9</li>
                        <li>WebLogic 8.1 and Oracle 9</li>
                    </ul>

                    <p>
                        Please <a href="mailto:info@orbeon.com">contact Orbeon</a> to inquire about
                        supporting additional systems.
                    </p>
                    <p>
                        Reading from CLOB columns on the other hand is supported with all JDBC
                        drivers that support the CLOB API.
                    </p>
                </warning>

            </section>

            <anchor id="binary-data"/>
            <section>
                <title>Reading and Writing Binary Data</title>
                <p>
                    Reading and writing binary data is supported to and from database Binary Large
                    OBjects (BLOBs) as well as binary types (<code>BINARY</code>, <code>VARBINARY
                    </code>and <code>LONGVARBINARY</code> SQL types). The
                    <code>xs:base64Binary</code> type (read and write) or the <code>xs:anyURI</code>
                    type (write only) must be used. To write to a BLOB, use the
                    <code>xs:base64Binary</code> type as follows:
                </p>
                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_blob_table (blob_column)
        values (<sql:param select="/*" type="xs:base64Binary"/>)
    </sql:update>
</sql:execute>
                </xml-source>
                <p>
                    The result of the XPath expression specified in the <code>select</code>
                    attribute is converted into a character string, following the XPath semantics.
                    That string is then interpreted as Base64-encoded data, before being written to
                    the BLOB column. For example, the following input document:
                </p>
                <xml-source>
<root>
/9j/4AAQSkZJRgABAQEBygHKAAD/2wBDAAQDAwQDAwQEBAQFBQQFBwsHBwYGBw4KCggLEA4R
...
KKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//2Q==
</root>
                </xml-source>
                <p>
                    Is converted to the following string when the expression <code>/*</code> is
                    applied:
                </p>
                <code>
/9j/4AAQSkZJRgABAQEBygHKAAD/2wBDAAQDAwQDAwQEBAQFBQQFBwsHBwYGBw4KCggLEA4R
...
KKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//2Q==
                </code>
                <p>
                    With <code>xs:anyURI</code>, the result of the XPath expression is converted
                    into a string and interpreted as a URL. The URL is read, and the resulting data
                    is stored into the BLOB column. For example:
                </p>
                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:update>
        insert into test_blob_table (blob_column)
        values (<sql:param select="/my/uri" type="xs:anyURI"/>)
    </sql:update>
</sql:execute>
                </xml-source>
                <note>
                    XForms file uploads typically generate URLs in XForms instances if the type
                    chosen for the uploaded file in the XForms model is <code>xs:anyURI</code>. The
                    advantage of using <code>xs:anyURI</code> is that large resources do not have
                    to reside entirely in memory.
                </note>
                <p>
                    To read a BLOB or BINARY column, use the <code>xs:base64Binary</code> type as
                    follows:
                </p>
                <xml-source>
<sql:execute xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:query>
        select blob_column from test_blob_table
    </sql:query>
    <sql:results>
        <rows>
            <sql:row-results>
                <row>
                    <sql:get-column type="xs:base64Binary" column="blob_column"/>
                </row>
            </sql:row-results>
        </rows>
    </sql:results>
</sql:execute>
                </xml-source>
                <p>
                    This will produce the following result if the document above was written to the
                    database first:
                </p>
                <xml-source>
<rows>
    <row>
/9j/4AAQSkZJRgABAQEBygHKAAD/2wBDAAQDAwQDAwQEBAQFBQQFBwsHBwYGBw4KCggLEA4R
...
KKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//2Q==
    </row>
</rows>
                </xml-source>
                <note>
                    <p>
                        Base64-encoded binary documents are widely used in PresentationServer, in
                        particular in the following cases:
                    </p>
                    <ul>
                        <li>
                            <p>
                                <a href="processors-generators-request">Request
                                generator</a>: as the result of certain types of HTML form
                                submissions (typically file uploads) or request body submission,
                                Base64-encoded representation of the uploaded files may be stored
                                into the request document.
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="reference-xforms#upload">XForms upload</a>: as the result
                                of a file upload, a Base64-encoded representation of the uploaded
                                file may be stored into the XForms instance.
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="processors-generators-url">URL generator</a>:
                                can read binary documents and produce Base64-encoded output
                                according to the standard <a
                                href="reference-formats#binary-documents">binary document
                                format</a>.
                            </p>
                        </li>
                        <li>
                            <p>
                                <a href="processors-serializers-http">HTTP
                                serializer</a>: can convert Base64-encoded input according to the
                                <a href="reference-formats#binary-documents">binary document
                                format</a> into a binary stream.
                            </p>
                        </li>
                        <li>
                            <p>
                                SQL processor: as described in this document, it is able to read
                                and write Base64-encoded binaries.
                            </p>
                        </li>
                    </ul>
                </note>

                <warning>
                    <p>
                        Writing to BLOB columns is currently only supported with the following
                        application server / database combinations:
                    </p>

                    <ul>
                        <li>Tomcat 4.1 and Oracle 9</li>
                        <li>WebLogic 8.1 and Oracle 9</li>
                    </ul>

                    <p>
                        Please <a href="mailto:info@orbeon.com">contact Orbeon</a> to inquire about
                        supporting additional systems.
                    </p>
                    <p>
                        Reading from BLOB columns on the other hand is supported with all JDBC
                        drivers that support the BLOB API.
                    </p>
                </warning>

            </section>

            <section>
                <title>sql:value-of and sql:copy-of</title>

                <p>
                    The <code>sql:value-of</code> and <code>sql:copy-of</code> elements have the
                    same semantics as their XSLT 1.0 couterparts. They work against the SQL
                    processor's input XML document.
                </p>

                <p>
                    Those elements support functions in the
                    <code>http://orbeon.org/oxf/xml/sql</code> namespace. The only function
                    supported for the moment is <code>sql:row-position()</code>, which returns, in a
                    <code>sql:row-results</code>, the index of the current row in the result set,
                    starting with row number <code>1</code>. For example:
                </p>

                <xml-source>
<sql:results xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <sql:row-results>
        <employee>
            <position><sql:value-of select="sql:row-position()"/></position>
            <first-name><sql:get-column type="xs:string" column="first_name"/></first-name>
            <last-name><sql:get-column type="xs:string" column="last_name"/></last-name>
        </employee>
    </sql:row-results>
</sql:results>
                </xml-source>

                <p>
                    This generates the following results:
                </p>

                <xml-source>
<employee>
    <position>1</position>
    <first-name>John</first-name>
    <last-name>Doe</last-name>
</employee>
<employee>
    <position>2</position>
    <first-name>Billy</first-name>
    <last-name>Smith</last-name>
</employee>
                </xml-source>

            </section>

            <section>
                <title>Multiple Updates</title>

                <p>The <code>sql:update</code> element supports an optional
                <code>select</code> attribute. It is evaluated as an XPath
                expression against the input XML document. The expression must
                return a node-set (which may be empty). The update statement is
                executed once for every node returned. <code>select</code>
                attributes on nested <code>sql:param</code> elements are
                evaluated using the selected node as current node. With the
                following input XML document:</p>

                <xml-source>
<employees>
    <employee>
        <first-name>John</first-name>
        <last-name>Doe</last-name>
    </employee>
    <employee>
        <first-name>Billy</first-name>
        <last-name>Smith</last-name>
    </employee>
</employees>
                </xml-source>

                <p>The following update inserts two rows in the database:</p>

                <xml-source>
<sql:update select="/employees/employee" xmlns:sql="http://orbeon.org/oxf/xml/sql">
insert into employee (first_name, last_name)
       values (<sql:param type="xs:string" select="first-name"/>,
               <sql:param type="xs:string" select="last-name"/>)
</sql:update>
                </xml-source>

            </section>

            <section>
                <title>Nested queries</title>

                <p>Consider the following three SQL tables organized in a tree.
                The level2 table references the level1 table, and the level3
                table references the level2 table.</p>

                <p>level1</p>

                <table>
                    <tr><th>level1_id</th><th>value</th></tr>
                    <tr><td>1</td><td>a</td></tr>
                    <tr><td>2</td><td>b</td></tr>
                </table>

                <p>level2</p>

                <table>
                    <tr><th>level2_id</th><th>level1_id</th><th>value</th></tr>
                    <tr><td>1</td><td>1</td><td>a</td></tr>
                    <tr><td>2</td><td>1</td><td>b</td></tr>
                    <tr><td>3</td><td>2</td><td>c</td></tr>
                    <tr><td>4</td><td>2</td><td>d</td></tr>
                </table>

                <p>level3</p>

                <table>
                    <tr><th>level2_id</th><th>value</th></tr>
                    <tr><td>1</td><td>a</td></tr>
                    <tr><td>1</td><td>b</td></tr>
                    <tr><td>2</td><td>c</td></tr>
                    <tr><td>2</td><td>d</td></tr>
                    <tr><td>3</td><td>e</td></tr>
                    <tr><td>3</td><td>f</td></tr>
                    <tr><td>4</td><td>g</td></tr>
                    <tr><td>4</td><td>h</td></tr>
                </table>

                <p>A flat representation of the three tables joined on their
                respective foreign keys yields the following rows:</p>

                <table>
                    <tr><th>level1.value</th><th>level2.value</th><th>level3.value</th></tr>
                    <tr><td>a</td><td>a</td><td>a</td></tr>
                    <tr><td>a</td><td>a</td><td>b</td></tr>
                    <tr><td>a</td><td>b</td><td>c</td></tr>
                    <tr><td>a</td><td>b</td><td>d</td></tr>
                    <tr><td>b</td><td>c</td><td>e</td></tr>
                    <tr><td>b</td><td>c</td><td>f</td></tr>
                    <tr><td>b</td><td>d</td><td>g</td></tr>
                    <tr><td>b</td><td>d</td><td>h</td></tr>
                </table>

                <p>Often it is useful to group results in order to output certain
                values only once. In a table, this can look like the following:</p>

                <table>
                    <tr><th>level1.value</th><th>level2.value</th><th>level3.value</th></tr>
                    <tr><td rowspan="4">a</td>  <td rowspan="2">a</td>  <td>a</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>b</td></tr>
                    <tr><pdf-td/>               <td rowspan="2">b</td>  <td>c</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>d</td></tr>
                    <tr><td rowspan="4">b</td>  <td rowspan="2">c</td>  <td>e</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>f</td></tr>
                    <tr><pdf-td/>               <td rowspan="2">d</td>  <td>g</td></tr>
                    <tr><pdf-td/>               <pdf-td/>               <td>h</td></tr>
                </table>

                <p>A generalization of this consists in generating output of the form:</p>

                <xml-source>
<result>
    <group1>
        <group1-header><level1-value>a</level1-value></group1-header>
        <group1-members>
            <group2>
                <group2-header><level2-value>a</level2-value></group2-header>
                    <group2-members>
                        <level3-value>a</level3-value>
                        <level3-value>b</level3-value>
                    </group2-members>
                <group2-footer><level2-value>a</level2-value></group2-footer>
            </group2>
            <group2>
                <group2-header><level2-value>b</level2-value></group2-header>
                    <group2-members>
                        <level3-value>c</level3-value>
                        <level3-value>d</level3-value>
                    </group2-members>
                <group2-footer><level2-value>b</level2-value></group2-footer>
            </group2>
        </group1-members>
        <group1-footer><level1-value>a</level1-value></group1-footer>
    </group1>
    <group1>
        <group1-header><level1-value>b</level1-value></group1-header>
        <group1-members>
            <group2>
                <group2-header><level2-value>c</level2-value></group2-header>
                    <group2-members>
                        <level3-value>e</level3-value>
                        <level3-value>f</level3-value>
                    </group2-members>
                <group2-footer><level2-value>c</level2-value></group2-footer>
            </group2>
            <group2>
                <group2-header><level2-value>d</level2-value></group2-header>
                    <group2-members>
                        <level3-value>g</level3-value>
                        <level3-value>h</level3-value>
                    </group2-members>
                <group2-footer><level2-value>d</level2-value></group2-footer>
            </group2>
        </group1-members>
        <group1-footer><level1-value>b</level1-value></group1-footer>
    </group1>
</result>
                </xml-source>

                <p>There are two ways of generating such results with XML-SQL.
                The first way is to use nested queries. A first query returns all the
                rows in the level1 table. Then, for each row returned, a second query
                returns all rows in the level2 table referencing the current row's
                level1_id. Similarly, for each row returned by that second query,
                a new query is done to get the relevant level3 rows. The code would look
                as follows:</p>

                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <results>
        <sql:connection>
            <sql:datasource>my-datasource</sql:datasource>
            <sql:execute>
                <sql:query>
select level1.value value, level1.level1_id id
  from level1
 order by level1.value
                </sql:query>
                <sql:results>
                    <sql:row-results>
                        <group1>
                            <group1-header>
                                <level1-value><sql:get-column type="xs:string" column="value"/></level1-value>
                            </group1-header>
                            <group1-members>
                                <sql:execute>
                                    <sql:query>
select level2.value value, level2.level2_id id
  from level2
 where level2.level1_id = <sql:param type="xs:int"><sql:get-column type="xs:int" column="id"/></sql:param>
 order by level2.value
                                    </sql:query>
                                    <sql:results>
                                        <sql:row-results>
                                            <group2>
                                                <group2-header>
                                                    <level2-value><sql:get-column type="xs:string" column="value"/></level2-value>
                                                </group2-header>
                                                <group2-members>
                                                    <sql:execute>
                                                        <sql:query>
select level3.value value
  from level3
 where level3.level2_id = <sql:param type="xs:int"><sql:get-column type="xs:int" column="id"/></sql:param>
 order by level3.value
                                                        </sql:query>
                                                        <sql:results>
                                                            <sql:row-results>
                                                                <level3-value><sql:get-column type="xs:string" column="value"/></level3-value>
                                                            </sql:row-results>
                                                        </sql:results>
                                                    </sql:execute>
                                                </group2-members>
                                                <group2-footer>
                                                    <level2-value><sql:get-column type="xs:string" column="value"/></level2-value>
                                                </group2-footer>
                                            </group2>
                                        </sql:row-results>
                                    </sql:results>
                                </sql:execute>
                            </group1-members>
                            <group1-footer>
                                <level1-value><sql:get-column type="xs:string" column="value"/></level1-value>
                            </group1-footer>
                        </group1>
                    </sql:row-results>
                </sql:results>
            </sql:execute>
        </sql:connection>
    </results>
</sql:config>
                </xml-source>

                <p>A nested query can access parameters from the input XML
                document like any regular query. It can also access results
                from outer queries by nesting a getter in a
                <code>sql:param</code> element. In that case, getters
                can take an optional <code>ancestor</code>
                attribute that specifies which level of outer query to
                access. If omitted, the <code>ancestor</code> attribute
                takes the value 1 when used in a <code>sql:query</code> or
                <code>sql:update</code>, which means the first outer query;
                it defaults to the value 0 when used in a
                <code>sql:row-results</code>, which means the query at the
                current level.</p>

            </section>

            <section>
                <title>Grouping</title>

                <p>
                    While nested queries have their uses, in the example above 3 queries have to be
                    written and no less than 7 queries are executed to produce the final result. It can
                    be elegantly rewritten using the <code>sql:group</code> and <code>sql:member</code>
                    elements. <code>sql:group</code> has to be the first element under a
                    <code>sql:row-results</code> or <code>sql:member</code> element. It takes a
                    mandatory <code>column</code> attribute that specifies the name of the column on
                    which grouping is done.
                </p>

                <p>
                    For every group, a header is output only once. Then, the content under the
                    <code>sql:member</code> element is output for each row. Finally, the footer is
                    output. The header and the footer can access columns There is no limit in
                    XML-SQL as to how deep grouping can be done.
                </p>

                <p>
                    The code below generates with a single SQL query the same results as the
                    example above:
                </p>

                <xml-source>
<sql:config xmlns:sql="http://orbeon.org/oxf/xml/sql">
    <results>
        <sql:connection>
            <sql:datasource>my-datasource</sql:datasource>
            <sql:execute>
                <sql:query>
select level1.value v1, level2.value v2, level3.value v3
  from level1, level2, level3
 where level1.level1_id = level2.level1_id
   and level2.level2_id = level3.level2_id
 order by level1.value, level2.value, level3.value
                </sql:query>
                <sql:results>
                    <sql:row-results>
                        <sql:group column="v1">
                            <group1>
                                <group1-header>
                                    <level1-value><sql:get-column type="xs:string" column="v1"/></level1-value>
                                </group1-header>
                                <group1-members>
                                    <sql:member>
                                        <sql:group column="v2">
                                            <group2>
                                                <group2-header>
                                                    <level2-value><sql:get-column type="xs:string" column="v2"/></level2-value>
                                                </group2-header>
                                                <group2-members>
                                                    <sql:member>
                                                        <level3-value><sql:get-column type="xs:string" column="v3"/></level3-value>
                                                    </sql:member>
                                                </group2-members>
                                                <group2-footer>
                                                    <level2-value><sql:get-column type="xs:string" column="v2"/></level2-value>
                                                </group2-footer>
                                            </group2>
                                        </sql:group>
                                    </sql:member>
                                </group1-members>
                                <group1-footer>
                                    <level1-value><sql:get-column type="xs:string" column="v1"/></level1-value>
                                </group1-footer>
                            </group1>
                        </sql:group>
                    </sql:row-results>
                </sql:results>
            </sql:execute>
        </sql:connection>
    </results>
</sql:config>
                </xml-source>

                <p>Note that correct ordering of the rows in the SQL query is
                important because headers and footers are output when the
                columns on which grouping is done change, in the order
                returned by the result set.</p>

                <p></p>

            </section>

            <section>
                <title>Text and Whitespace Handling</title>

                <p>Like in XSLT 1.0, text nodes in the XML-SQL document containing
                only whitespace characters are stripped. Text nodes that contain
                at least one non-whitespace character are not stripped and copied
                to the output.</p>

                <p>
                    To better control the output of text, the <code>sql:text</code> element is
                    provided. It is similar to the <code>xsl:text</code> element.
                    <code>xsl:text</code> encapsulate text that is output as is. In particular, it
                    can encapsulate all whitespace characters.
                </p>

            </section>
        </section>
        <section>
            <title>Transactions</title>
            <p>
                PresentationServer executes each HTTP request in its own transaction. If a
                request fails for any reason, the SQL Processor rolls back the
                transaction. The transaction is committed only when the pipeline
                execution in complete.
            </p>
        </section>
    </body>
</document>

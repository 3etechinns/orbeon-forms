<?xml version="1.0" encoding="iso-8859-1"?>
<!--<!DOCTYPE spec PUBLIC "-//W3C//DTD Specification V2.1//EN"-->
<!-- "http://www.w3.org/XML/1998/06/xmlspec-v21.dtd" [-->
<!DOCTYPE spec [
<!ENTITY doctype "NOTE">
<!ENTITY nickname "pipeline">
<!ENTITY http-ident "http://www.orbeon.com/oxf/">
<!ENTITY draft.month "01">
<!ENTITY draft.monthname "January">
<!ENTITY draft.day "24">

<!ENTITY % local.p.class "|xi:include">
<!ENTITY % local.annot.class "|xi:include">

<!ENTITY draft.year "2005">
<!ENTITY iso6.doc.date "&draft.year;&draft.month;&draft.day;">
<!ENTITY draft-name "NOTE-xml-pipeline">
<!ENTITY namespaceName "http://www.orbeon.com/oxf/pipeline">
]>
<spec w3c-doctype="note" xmlns:xlink="http://www.w3.org/1999/xlink">
    <header>
        <title>XML Pipeline Language (XPL)</title>
        <version>Version 1.0</version>
        <w3c-designation>&doctype;-&nickname;-&iso6.doc.date;</w3c-designation>
<!--        <w3c-doctype>W3C Note</w3c-doctype>-->
        <w3c-doctype>Orbeon Draft Note</w3c-doctype>
        <pubdate>
            <day>&draft.day;</day>
            <month>&draft.monthname;</month>
            <year>&draft.year;</year>
        </pubdate>
        <publoc>
            <loc href="&http-ident;&draft.year;/&doctype;-&nickname;-&iso6.doc.date;">&http-ident;&draft.year;/&doctype;-&nickname;-&iso6.doc.date;/</loc>
<!--            (in-->
<!--            <loc href="&http-ident;&draft.year;/&doctype;-&nickname;-&iso6.doc.date;/Overview.html">HTML</loc>-->
<!--            and-->
<!--            <loc href="&http-ident;&draft.year;/&doctype;-&nickname;-&iso6.doc.date;/Overview.xml">XML</loc>-->
<!--            with separate provision of the-->
<!--            <loc href="http://www.w3.org/2002/02/xml-pipeline.xsd">Pipeline schema</loc>)-->
        </publoc>
        <latestloc>
            <loc href="&http-ident;&nickname;/">&http-ident;&nickname;/</loc>
        </latestloc>
        <authlist>
            <author>
                <name>Erik Bruchez</name>
                <affiliation>Orbeon, Inc.</affiliation>
                <email href="mailto:ebruchez@orbeon.com">ebruchez@orbeon.com</email>
            </author>
        </authlist>
        <copyright>
            <p>
                Copyright © 2005 <loc href="http://www.orbeon.com/">Orbeon, Inc.</loc>
            </p>
        </copyright>
        <abstract>
            <p>
                This Note describes the features and syntax for the XPL XML Pipeline Language, an
                XML vocabulary for describing a processing model for XML components.
            </p>
        </abstract>
        <status>
            <p>
                This document is currently an internal draft note by Orbeon, Inc. It has not been
                submitted to the W3C or any other standard body, even though it follows closely the
                format of a W3C Note.
            </p>
        </status>
        <sourcedesc>
            <p>Created in electronic form.</p>
        </sourcedesc>
        <langusage>
            <language id="EN">English</language>
        </langusage>
        <revisiondesc>
            <slist>
                <sitem>January 2005: Submission made.</sitem>
            </slist>
        </revisiondesc>
    </header>
    <body>
        <div1 id="intro">
            <head>Introduction</head>
            <div2 id="terminology">
                <head>What is XPL?</head>
                <p>
                    This specification defines the syntax and semantics of the XPL 1.0 language.
                </p>
                <termdef id="xpl-program" term="XPL program">
                    An <term>XPL program</term> or <term>program in the XPL language</term> is a
                    well-formed XML document whose syntax is well-formed XML <bibref ref="xml-10"/>
                    conforming to the Namespaces in XML Recommendation <bibref
                    ref="xml-namespaces-10"/>. Furthermore, the XML document must conform to the
                    syntax of the XPL language described in this specification.
                </termdef>
                <p>
                    An XPL program defines orchestrated sequences of operations on XML Information
                    Sets (Infosets). Individual operations are encapsulated within components called
                    XML processors. Operations include production, consumption, and transformation
                    of XML Infosets. An XPL program supports unconditional operations, and may
                    support as well conditions, loops, and change of control following runtime
                    errors.
                </p>
            </div2>
            <div2 id="motivation">
                <head>Motivation</head>
                <p>
                    A growing number of specifications describe operations on XML documents. The
                    best-known specification is <bibref ref="xslt-10"/>, a language designed to
                    transform XML documents into other XML documents. There are other such
                    specifications, including <bibref ref="xquery-10"/>, validation languages like
                    <bibref ref="relax-ng"/> and <bibref ref="xml-schema"/>. No current
                    specification adequately addresses the interoperability of those specifications
                    from the point of view of the XML Infosets they produce or consume. XPL
                    addresses this problem.
                </p>
            </div2>
        </div1>
        <div1 id="concepts">
            <head>Concepts</head>
            <div2 id="terminology">
                <head>Terminology</head>
                <p>
                    <termdef id="dt-must" term="Must, May, etc.">The key words
                        <term>must</term>,
                        <term>must not</term>,
                        <term>required</term>,
                        <term>shall</term>,
                        <term>shall not</term>,
                        <term>should</term>,
                        <term>should not</term>,
                        <term>recommended</term>,
                        <term>may</term>, and
                        <term>optional</term>
                        in this specification are to be interpreted as described in
                        <bibref ref="rfc2119"/>.
                    </termdef>
                </p>
                <p>
                    <termdef id="Infoset" term="information set">
                        The term <term>information set</term> refers to the output of an <bibref
                        ref="xml-10"/> or <bibref ref="xml-11"/> processor, expressed as a
                        collection of information items and properties as defined by the <bibref
                        ref="xml-infoset"/> specification.] In this document the term Infoset is
                        used as a synonym for information set.
                    </termdef>
                </p>
            </div2>
            <div2 id="notation">
                <head>Notation</head>
                <p>
                    In this document the specification of each XPL-defined element type is preceded
                    by a summary of its syntax in the form of a model for elements of that element
                    type. The meaning of syntax summary notation is as defined in <bibref
                    ref="xslt-20"/>, section 2.2.
                </p>
            </div2>
            <div2>
                <head>XPL Implementation</head>
                <termdef id="xplimplementation" term="XPL implementation">
                    A specific software product able execute an XPL program according to the XPL
                    specification is referred to as an <term>XPL implementation</term>.
                </termdef>
                <p>
                    The XPL specification does not put any requirement on the underlying software
                    platform other than being able to execute an XPL program. In fact it is hoped
                    that XPL will be implemented in various programming languages on various
                    platforms.
                </p>
            </div2>
            <div2>
                <head>Error Handling</head>
                <p>
                    The following definitions are borrowed from <bibref ref="xslt-20"/> with minor
                    adjustments.
                </p>
                <p>
                    <termdef id="static-error" term="static error">
                        An error that is detected by examining an XPL program before execution
                        starts is referred to as a <term>static error</term>.
                    </termdef>
                </p>
                <p>
                    <termdef id="dynamic-error" term="dynamic error">
                        An error that is not detected until an XPL program is executed is referred
                        to as a <term>dynamic error</term>.
                    </termdef>
                </p>
                <p>
                    <termdef id="recoverable-errors" term="recoverable errors">
                        Some dynamic errors are classed as <term>recoverable errors</term>. When a
                        recoverable error occurs, this specification allows the XPL implementation
                        either to signal the error (by reporting the error condition and terminating
                        execution) in the basic profile or to take a defined recovery action and
                        continue processing when the exception module is available.
                    </termdef>
                </p>
<!--                <p>-->
<!--                    [Definition: If an implementation recovers from a recoverable dynamic error, it-->
<!--                    must take the recovery action defined for that error condition in this-->
<!--                    specification.]-->
<!--                </p>-->
                <p>
                    <termdef id="non-recoverable-dynamic-error" term="non-recoverable dynamic error">
                        A dynamic error that is not recoverable is referred to as a
                        <term>non-recoverable dynamic error</term>. When a non-recoverable dynamic
                        error occurs, the XPL implementation must signal the error, and the
                        execution of the XPL program fails.
                    </termdef>
                </p>
            </div2>
            <div2>
                <head>Qualified Names</head>
                <p>
                    The following definitions are borrowed from <bibref ref="xslt-20"/> with minor
                    adjustments.
                </p>
                <p>
                    XML processors referred to by XPL are specified as a <termref
                    def="qname">QName</termref> using the syntax for <a
                    href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> as defined in
                    <bibref ref="xml-namespaces-10"/>.
                </p>
                <p>
                    <termdef id="qname" term="QName">
                        A <term>QName</term> is always written in the form <code>(NCName ":")?
                        NCName</code>, that is, a local name optionally preceded by a namespace prefix.
                        When two QNames are compared, however, they are considered equal if the
                        corresponding <termref def="expanded-qname">expanded-QNames</termref> are the
                        same, as described below.
                    </termdef>
                </p>
                <p>
                    Because an atomic value of type <code>xs:QName</code> is sometimes referred to
                    loosely as a QName, this specification also uses the term <termref
                    def="lexical-qname">lexical QName</termref> to emphasize that it is referring to
                    a <a href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a> in its
                    lexical form rather than its expanded form. This term is used especially when
                    strings containing lexical QNames are manipulated as run-time values.
                </p>
                <p>
                    <termdef id="lexical-qname" term="lexical QName">
                        A <term>lexical QName</term> is a string representing a <termref
                        def="qname">QName</termref> in the form <code>(NCName ":")? NCName</code>,
                        that is, a local name optionally preceded by a namespace prefix.
                    </termdef>
                </p>
                <p>
                    <termdef id="defining-element" term="defining element">
                        A string in the form of a lexical QName may occur as the value of an attribute
                        node in a stylesheet module, or within an XPath expression contained in such an
                        attribute node, or as the result of evaluating an XPath expression contained in
                        such an attribute node. The element containing this attribute node is referred
                        to as the <term>defining element</term> of the QName.
                    </termdef>
                </p>
                <p>
                    <termdef id="expanded-qname" term="expanded-QName">
                        An <term>expanded-QName</term> contains a pair of values, namely a local name
                        and an optional namespace URI. It may also contain a namespace prefix. Two
                        expanded-QNames are equal if the namespace URIs are the same (or both absent)
                        and the local names are the same. The prefix plays no part in the comparison,
                        but is used only if the expanded-QName needs to be converted back to a string.
                    </termdef>
                </p>
                <p>
                    If the QName has a prefix, then the prefix is expanded into a URI reference
                    using the namespace declarations in effect on its <termref
                    def="defining-element">defining element</termref>. The <termref
                    def="expanded-qname">expanded-QName</termref> consisting of the local part of
                    the name and the possibly null URI reference is used as the name of the object.
                </p>
                <p>
                    In the case of a prefixed QName used as the value of an attribute in the XPL
                    program, or appearing within an XPath expression in the stylesheet, it is a
                    static error if the defining element has no namespace node whose name matches
                    the prefix of the QName.
                </p>
            </div2>
        </div1>
        <div1 id="processors">
            <head>XML Processors</head>
            <div2>
                <head>Definition</head>
                <p>
                    <termdef id="xml-processor" term="XPL processor">
                        An <term>XML processor</term> is a component used in an <termref
                        def="xpl-program">XPL program</termref> and identified by a <termref
                        def="qname">QName</termref>.
                    </termdef>
                </p>
                <p>
                    An XML processor is composed of:
                </p>
                <ulist>
                    <item>
                        <p><emph>A set of inputs and outputs</emph>, defining how the XML processor
                        interfaces with an XPL program. See <specref
                        ref="processor-interface"/>.</p>
                    </item>
                    <item>
                        <p><emph>A behavior</emph>, defining tasks performed by the XML processor
                        during the execution of an XPL program. See <specref
                        ref="processor-behavior"/>.</p>
                    </item>
                </ulist>
                <p>
                    A small set of XML processors must be provided by the XPL implementations. See
                    <specref ref="standardprocessors"/>. However most of the XML processors provided
                    by an XPL implementations are implementation-defined. XPL implementations may
                    also choose to be extensible and allow users of the implementation to provide
                    their own XML processors.
                </p>
                <p>
                    The use of a <termref def="qname">QName</termref> to identify an XML processor
                    has the following benefits:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>Shorter to write by hand than full URIs.</emph> Once an XML
                            namespace prefix mapping is done, a qualified name only requires typing
                            a prefix, which can be as short as one character, and a local name.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Allows for logical grouping of processors.</emph> A single URI
                            regroups the XML processors in a certain category, for example the XML
                            processors implemented by a certain company.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Consistency with other specifications.</emph> <bibref
                            ref="xslt-20"/> for example, uses qualified names to identify
                            stylesheet-defined objects such as functions.
                        </p>
                    </item>
                </ulist>
                <p>
                    The definition of the mapping between a particular QName and an XML processor
                    implementation is outside the scope of XPL.
                </p>
            </div2>
            <div2 id="processor-instance">
                <head>Instances</head>
                <p>
                    <termdef id="xml-processor-instance" term="XML processor instance">
                        An <term>XML processor instance</term> designate a specific use of a
                        processor in a pipeline.
                    </termdef>
                </p>
                <p>
                    An XML processor used in an XPL program is always <emph>instantiated</emph>.
                    Multiple instances of the same XML processor may occur in an XPL program.
                </p>
                <p>
                    XPL does not specify if or how an XML processor is instantiated or keeps state
                    information during an XPL program execution.
                </p>
            </div2>
            <div2 id="processor-interface">
                <head>Inputs and Outputs</head>
                <p>
                    Inputs and outputs connect an XML processor instance to the rest of the
                    pipeline. Each input may provide an XML Infoset to the XML processor instance.
                    Each output may provide an XML Infoset produced by the processor instance.
                </p>
                <p>
                    <termdef id="static-input-output" term="static input or output">
                        A <term>static input or output</term> designate an input or output defined by an
                        <termref def="xml-processor">XML processor</termref> before the execution of
                        the <termref def="xpl-program">XPL program</termref>.
                    </termdef>
                </p>
                <p>
                    <termdef id="connected-input-output" term="connected input of output">
                        A <term>connected input or output</term> designate an input or output of an XML
                        processor instance declared in an <termref def="xpl-program">XPL
                        program</termref>.
                    </termdef>
                </p>
                <p>
                    <termdef id="dynamic-input-output" term="dynamic input of output">
                        A <term>dynamic input or output</term> designate a connected input or output of
                        an XML processor instance which is not defined by the XML processor before the
                        execution of the <termref def="xpl-program">XPL program</termref>
                    </termdef>
                </p>
                <p>
                    Each XML processor instance has:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>A set of inputs each identified by a name.</emph> No two inputs
                            input may have the same name. The set of inputs may be empty.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>A set of outputs each identified by a name.</emph> No two outputs
                            output may have the same name. The set of outputs may be empty.
                        </p>
                    </item>
                </ulist>
                <p>
                    For each static input or output, the XML processor defines if the input or
                    output is:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>Mandatory.</emph> Such input or output must be connected in an XPL
                            program. The XPL implementation should raise a static error if a
                            statically defined mandatory input or output is not connected for a
                            given XML processor instance.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Optional.</emph> Such input or output may or may not be connected
                            in an XPL program.
                        </p>
                    </item>
                </ulist>
                <p>
                    <table border="1" align="center">
                        <tr>
                            <td rowspan="2"/>
                            <th colspan="2">Static</th>
                            <th rowspan="2">Dynamic</th>
                        </tr>
                        <tr>
                            <th>Mandatory</th>
                            <th>Optional</th>
                        </tr>
                        <tr>
                            <th>Connected</th>
                            <td>OK</td>
                            <td>OK</td>
                            <td>OK</td>
                        </tr>
                        <tr>
                            <th>Not connected</th>
                            <td>Invalid</td>
                            <td>OK</td>
                            <td>Inexistent by definition</td>
                        </tr>
                    </table>
                </p>
                <note>
                    The mechanism by which an XPL processor exposes inputs and outputs, and whether
                    they are mandatory or optional to the XPL implementation is outside the scope
                    of this specification.
                </note>
            </div2>
            <div2 id="processor-behavior">
                <head>Behavior</head>
                <p>
                    The behavior of an XML processor is for the most part outside the scope of this
                    specification, with the exception of the following aspects:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>Change of control.</emph> The XPL implementation may give control
                            to an XML processor instance, in association with exactly zero or one
                            connected output. If the XML processor instance has at least one
                            connected output, the XPL implementation will always give control to the
                            XML processor in association with an output. If the XPL implementation
                            gives control the XML processor instance in association with an output,
                            while in control the XML processor instance must "produce" an XML
                            Infoset associated with that output. If the XPL implementation did not
                            associate an output, the XML processor does not generate an XML Infoset.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Generating an error.</emph> The XML processor instance, when
                            having control, may generate an error that is propagated to the XPL
                            implementation. The XPL implementation then raises a dynamic error.
                            Even if the XPL implementation is expecting a resulting XML Infoset, no
                            such XML Infoset is provided by the XML processor. With the exception
                            module, the error is considered an exception and may be a recoverable
                            dynamic error. This means that if an exception handler is available for
                            that exception, it can be caught and processing may resume. Otherwise,
                            the error is a non-recoverable dynamic error. With the basic profile,
                            all errors raised by an XML processor are non-recoverable dynamic
                            errors.
                        </p>
                        <p>
                            Example 1: An XML processor may generate an error if an XML Infosets
                            read on any of its inputs does not conform to a format expected by the
                            XML processor. Similarly, the interaction with other software may cause
                            the XML processor to report errors.
                        </p>
                        <p>
                            Example 2: An XML processor may generate an error if the interaction
                            with other software reports an error.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Reading inputs.</emph> The XML processor instance, when having
                            control, may read one or more of its connected inputs. "Reading an
                            input" means that the XML processor instance asks the XPL implementation
                            to produce the XML Infoset associated with that particular connected
                            input.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Reading outputs.</emph> "Reading an output" means that the XML
                            implementation gives control to an XML processor instance in association
                            with an output. When in control, the XML processor instance must produce
                            the XML Infoset associated with that particular output. If the XML
                            implementation reads a dynamic output, the XML processor instance may
                            generate an error if it does not support that output.
                        </p>
                    </item>
                </ulist>
                <p>
                    While in control, an XML processor instance may perform other tasks, like
                    interacting with other software. Such tasks are outside the scope of the present
                    specification.
                </p>
                <p>
                    XPL does not specify the format or API used by the XPL implementation to
                    provide XML Infosets to an XML processor, or how an XML processor returns XML
                    Infosets to the XPL implementation.
                </p>
            </div2>
        </div1>
<!--        <div1 id="processors">-->
<!--            <head>XML Processors</head>-->
<!--            <div2>-->
<!--                <head>Definition</head>-->
<!--                <p>-->
<!--                    <termdef id="xml-processor" term="XPL processor">-->
<!--                        An <term>XML processor</term> is a component used in an <termref-->
<!--                        def="xpl-program">XPL program</termref> and identified by a <termref-->
<!--                        def="qname">QName</termref>.-->
<!--                    </termdef>-->
<!--                </p>-->
<!--                <p>-->
<!--                    An XML processor is composed of:-->
<!--                </p>-->
<!--                <ulist>-->
<!--                    <item>-->
<!--                        <p><emph>An interface</emph>, defining how the XML processor interfaces-->
<!--                        with an XPL program. See <specref ref="processor-interface"/>.</p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p><emph>A behavior</emph>, defining tasks performed by the XML processor-->
<!--                        during the execution of an XPL program. See <specref-->
<!--                        ref="processor-behavior"/>.</p>-->
<!--                    </item>-->
<!--                </ulist>-->
<!--                <p>-->
<!--                    A small set of XML processors must be provided by the XPL implementations. See-->
<!--                    <specref ref="standardprocessors"/>. However most of the XML processors provided-->
<!--                    by an XPL implementations are implementation-defined. XPL implementations may-->
<!--                    also choose to be extensible and allow users of the implementation to provide-->
<!--                    their own XML processors.-->
<!--                </p>-->
<!--                <p>-->
<!--                    The use of a <termref def="qname">QName</termref> to identify an XML processor-->
<!--                    has the following benefits:-->
<!--                </p>-->
<!--                <ulist>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Shorter to write by hand than full URIs.</emph> Once an XML-->
<!--                            namespace prefix mapping is done, a qualified name only requires typing-->
<!--                            a prefix, which can be as short as one character, and a local name.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Allows for logical grouping of processors.</emph> A single URI-->
<!--                            regroups the XML processors in a certain category, for example the XML-->
<!--                            processors implemented by a certain company.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Consistency with other specifications.</emph> <bibref-->
<!--                            ref="xslt-20"/> for example, uses qualified names to identify-->
<!--                            stylesheet-defined objects such as functions.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                </ulist>-->
<!--                <p>-->
<!--                    The definition of the mapping between a particular QName and an XML processor-->
<!--                    implementation is outside the scope of XPL.-->
<!--                </p>-->
<!--            </div2>-->
<!--            <div2 id="processor-interface">-->
<!--                <head>Interface</head>-->
<!--                <p>-->
<!--                    The interface of an XML processor interface consists of:-->
<!--                </p>-->
<!--                <ulist>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>A set of inputs each identified by a name.</emph> No two inputs-->
<!--                            input may have the same name. Each input may provide a particular XML-->
<!--                            Infoset to the XML processor. The set of inputs may be empty.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>A set of outputs each identified by a name.</emph> No two outputs-->
<!--                            output may have the same name. Each output may provide an XML Infoset-->
<!--                            produced by the processor. The set of outputs may be empty.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                </ulist>-->
<!--                <p>-->
<!--                    An input name uniquely identifies a processor input, and an output name uniquely-->
<!--                    identifies a processor output.-->
<!--                </p>-->
<!--                <p>-->
<!--                    The interface of a processor can include the following types of inputs and-->
<!--                    outputs:-->
<!--                </p>-->
<!--                <ulist>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Mandatory inputs and outputs.</emph> Such inputs and outputs must-->
<!--                            be connected in an XPL program.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Optional inputs and outputs.</emph> Such inputs and outputs may or-->
<!--                            may not be connected in an XPL program.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                </ulist>-->
<!--                <p>-->
<!--                    Inputs and outputs parts of the interface of a processor may be defined:-->
<!--                </p>-->
<!--                <ulist>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Statically.</emph> This means that the XML processor exposes such-->
<!--                            inputs and outputs to the XPL implementation before the execution of the-->
<!--                            XPL program. The XPL implementation should raise a static error if a-->
<!--                            statically defined mandatory input or output is exposed but not-->
<!--                            connected.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Dynamically.</emph> This means that the XML processor exposes such-->
<!--                            inputs and outputs to the XPL implementation only during the execution-->
<!--                            of the XPL program. It may do so at different times during execution for-->
<!--                            different inputs and outputs. The XPL implementation should raise a-->
<!--                            dynamic error if a dynamically defined mandatory input or output is-->
<!--                            exposed but is not connected. The XPL implementation must raise a-->
<!--                            dynamic error if an XML Infoset associated with any such output is-->
<!--                            requested during execution and the XML processor has not exposed that-->
<!--                            output to the XPL implementation.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                </ulist>-->
<!--                <note>-->
<!--                    The mechanism by which an XPL processor exposes inputs and outputs to the XPL-->
<!--                    implementation, and whether they are mandatory or optional, is outside the-->
<!--                    scope of this specification.-->
<!--                </note>-->
<!--            </div2>-->
<!--            <div2 id="processor-behavior">-->
<!--                <head>Behavior</head>-->
<!--                <p>-->
<!--                    The behavior of an XML processor is for the most part outside the scope of this-->
<!--                    specification, with the exception of the following aspects:-->
<!--                </p>-->
<!--                <ulist>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Change of control.</emph> The XPL implementation may give control-->
<!--                            to the XML processor, in association with exactly zero or one processor-->
<!--                            output. If the XML processor interface has at least one connected-->
<!--                            output, the XPL implementation will always give control to the XML-->
<!--                            processor in association with an output.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Reading inputs.</emph> The XML processor, when having control, may-->
<!--                            read one or more of its inputs. "Reading an input" means that the XML-->
<!--                            processor asks the XPL implementation to produce the XML Infoset-->
<!--                            associated with that particular input.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Producing resulting XML Infosets.</emph> The XML processor, when-->
<!--                            returning control to the XPL implementation, must "produce" an XML-->
<!--                            Infoset associated with the output associated when the XPL-->
<!--                            implementation gave control to the XML processor. If the XPL-->
<!--                            implementation did not associate an output because the XML processor-->
<!--                            does not have any, the XML processor does not generate an XML Infoset.-->
<!--                            If the XML processor has not exposed the output that the XPL-->
<!--                            implementation is associating, the XPL implementation must raise a-->
<!--                            dynamic error.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Generating an error.</emph> The XML processor, when having-->
<!--                            control, may generate an error that is propagated to the XPL-->
<!--                            implementation. The XPL implementation then raises a dynamic error.-->
<!--                            Even if the XPL implementation is expecting a resulting XML Infoset,-->
<!--                            no such XML Infoset is provided by the XML processor. With the exception-->
<!--                            module, the error is considered an exception and may be a recoverable-->
<!--                            dynamic error. This means that if an exception handler is available for-->
<!--                            that exception, it can be caught and processing may resume. Otherwise,-->
<!--                            the error is a non-recoverable dynamic error. With the basic profile,-->
<!--                            all errors raised by an XML processor are non-recoverable dynamic-->
<!--                            errors.-->
<!--                        </p>-->
<!--                        <p>-->
<!--                            Example 1: An XML processor may generate an error if an XML Infosets-->
<!--                            read on any of its inputs does not conform to a format expected by the-->
<!--                            XML processor. Similarly, the interaction with other software may cause-->
<!--                            the XML processor to report errors.-->
<!--                        </p>-->
<!--                        <p>-->
<!--                            Example 2: An XML processor may generate an error if the interaction-->
<!--                            with other software reports an error.-->
<!--                        </p>-->
<!--                    </item>-->
<!--                </ulist>-->
<!--                <p>-->
<!--                    An XML processor may perform other tasks, like interacting with other software.-->
<!--                    Such tasks are outside the scope of the present specification.-->
<!--                </p>-->
<!--                <p>-->
<!--                    XPL does not specify the format or API used by the XPL implementation to-->
<!--                    provide XML Infosets to an XML processor, or how an XML processor returns XML-->
<!--                    Infosets to the XPL implementation.-->
<!--                </p>-->
<!--            </div2>-->
<!--            <div2 id="processor-instance">-->
<!--                <head>Instances</head>-->
<!--                <p>-->
<!--                    <termdef id="xml-processor-instance" term="XML processor instance">-->
<!--                        An <term>XML processor instance</term> consists of an XML processor-->
<!--                        identified by a QName, a set of inputs and outputs connected to that-->
<!--                        processor within an XPL program, and an optional implementation-dependent-->
<!--                        execution state.-->
<!--                    </termdef>-->
<!--                </p>-->
<!--                <p>-->
<!--                    An XML processor used in an XPL program is always <emph>instanciated</emph>.-->
<!--                    Multiple instances of the same XML processor may occur in an XPL program.-->
<!--                </p>-->
<!--                <p>-->
<!--                    XPL does not specify if or how an XML processor is instanciated or keeps state-->
<!--                    information during an XPL program execution.-->
<!--                </p>-->
<!--            </div2>-->
<!--        </div1>-->
        <div1 id="xpl-program">
            <head>XPL Program</head>
            <div2>
                <head>Structure</head>
                <p>
                    An <termref def="xpl-program">XPL program</termref> consists of:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>Input and output parameters.</emph> Each input or output has a
                            name, and may either provide the XPL program with an XML Infoset (case
                            of an input), or produces an XML Infoset (case of an output). The XPL
                            program may have no input or outputs.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>A sequence of statements.</emph> Statements are discussed in
                            <specref ref="statements"/> and sequences of statements in <specref
                            ref="statements-sequence"/>.
                        </p>
                    </item>
                </ulist>
                <note>
                    Some use cases do not require that an XPL program have any inputs or outputs. It
                    is important to note that information, whether in the form or XML Infosets or
                    other forms, is not necessarily exchanged with XPL programs through pipeline
                    inputs and outputs, but possibly with other means. For example, an XML processor
                    can access information by connecting to a relational database and return an XML
                    Infoset to the XPL program.
                </note>
            </div2>
            <div2>
                <head>XML Infoset Identifiers</head>
                <termdef id="Infosetid" term="XML Infoset identifier">
                    An <term>XML Infoset identifier</term> is an identifier that refers to a
                    particular XML Infoset. Within the execution of a <specref
                    ref="statements-sequence"/>, an XML Infoset identifier may be used multiple times.
                    In that case it must always refer to the exact same XML Infoset. See <specref
                    ref="output-invariance"/>.
                </termdef>
                <p>
                    In XPL, XML Infoset identifiers are exposed by statements using the <el>id</el>
                    attribute.
                </p>
            </div2>
            <div2 id="statements">
                <head>Statements</head>
                <p>
                    An XPL program statement is an element with the following characteristics:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>Scoped XML Infoset Identifiers.</emph> A set of XML Infoset
                            identifiers in scope at the point where the statement occurs in the XPL
                            program. The set may be empty.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Exposed XML Infoset Identifiers.</emph> A set of XML Infoset
                            identifiers exposed by the statement. There cannot be an intersection
                            between the scoped XML infoset identifiers and the exposed XML infoset
                            identifiers. For example, a statement can attempt to expose, with an
                            <el>id</el> attribute on a <el>p:output</el> element, an XML Infoset
                            identifier already present in the set of scoped XML infoset identifiers.
                            Such a condition must raise a static error. This is referred to as the
                            <emph>no-collision rule</emph>.
                        </p>
                    </item>
<!--                    <item>-->
<!--                        <p>-->
<!--                            <emph>Post-Statement Scope.</emph> A set of XML Infoset identifiers-->
<!--                            consisting of the logical union of the scoped XML infoset identifiers-->
<!--                            with a set of new XML Infoset identifiers defined by the statement. The-->
<!--                            post-statement scope may be identical to the scoped XML infoset-->
<!--                            identifiers, or larger than the scoped XML infoset identifiers. It may-->
<!--                            never be smaller.-->
<!--                        </p>-->
<!--                    </item>-->
                </ulist>
                <p>
                    The set of XML Infoset identifiers in scope for a statement of an XPL program,
                    unless specified otherwise, consists of the union of the identifiers in scope
                    for the previous statement and the identifiers exposed by the previous statement
                    in document order.
                </p>
                <p>
                    If there is no previous statement, the set of XML Infoset identifiers in scope
                    for a statement of an XPL program , unless specified otherwise, consists of the
                    set of <el>id</el> attributes of the XPL program inputs.
                </p>
                <p>
                    In this specification, a statement consists of either a <el>p:processor</el>,
                    <el>p:choose</el> or <el>p:for-each</el> element. A statement may contain
                    nested statements. For example, <el>p:choose</el> may contain one or more
                    <el>p:processor</el> elements.
                </p>
                <p>
                    [TODO: update this with rest of repeat module and exception module.]
                </p>
            </div2>
            <div2 id="statements-sequence">
                <head>Sequence of Statements</head>
                <termdef id="sequenceofstatements" term="sequence of statements">
                    A <term>Sequence of Statements</term> is an ordered collection of zero or more
                    statements directly contained under a parent element such as <el>p:pipeline</el>
                    or <el>p:for-each</el>. All the statements are elements sharing the same
                    parent element.
                </termdef>
                <note>
                    The term <term>sequence</term> is here used with the meaning defined in <bibref
                    ref="xpath-20"/>, as an ordered collection of zero or more items (here, of
                    elements). It does not imply that statements will be executed in the order they
                    appear.
                </note>
            </div2>
        </div1>
        <div1 id="syntax">
            <head>Syntax</head>
            <div2>
                <head>Introduction</head>
                <p>
                    The XPL syntax is organized into modules. The Pipeline module and the Processor
                    module constitute the basic framework of XPL. Other modules build on top that
                    framework to provide enhanced functionality. Modules are then grouped into
                    profiles, see <specref ref="conformance"/>.
                </p>
            </div2>
            <div2>
                <head>Namespace</head>
                <p>
                    All the elements defined by XPL must be in the
                    <code>http://www.orbeon.com/oxf/pipeline</code> namespace [TODO: a
                    company-agnostic namespace must be chosen]. For consistency, XPL elements should
                    use the prefix <code>p</code>. This document assumes that this prefix is used.
                </p>
            </div2>
            <div2>
                <head>Pipeline Module</head>
                <div3>
                    <head>The <el>p:pipeline</el> element</head>
                    <pre>
&lt;p:pipeline
    version = "1.0" &gt;
    &lt;!-- Content: (p:input*, p:output*, (p:processor | p:choose | p:for-each)*) --&gt;
&lt;/p:pipeline&gt;
                    </pre>
                    <p>
                        An <termref def="xpl-program">XPL program</termref> always starts with a
                        <el>p:pipeline</el> element. The <el>p:pipeline</el> element must be the
                        root element of the XML document containing the XPL program.
                    </p>
                    <p>
                        The <el>p:pipeline</el> element has a mandatory <el>version</el> attribute.
                        The value of the version attribute must be a valid instance of the type
                        <code>xs:decimal</code> as defined in <bibref ref="xml-schema"/>.
                    </p>
                    <p>
                        For this version of XPL, the value of the <el>version</el> attribute must
                        be <code>1.0</code>.
                    </p>
                </div3>
                <div3>
                    <head>The <el>p:input</el> element</head>
                    <pre>
&lt;p:input
    name = <emph>ncname</emph>
    id? = <emph>ncname</emph>
    schema-uri? = <emph>aaa</emph>
    schema-href? = <emph>aaa</emph> /&gt;
                    </pre>
                    <p>
                        The <el>p:input</el> element defines exactly one XPL program input. Zero,
                        one or more <el>p:input</el> or <el>p:output</el> elements can be children
                        elements of the <el>p:pipeline</el> element. They must occur before any
                        other element in the XPL program.
                    </p>
                    <p>
                        The <el>name</el> attribute is mandatory. It identifies the input to
                        external users of the XPL program. There cannot be two inputs with the same
                        name, but it is possible to have an input and an output with the same name.
                        It is a static error if two inputs have the same name.
                    </p>
                    <p>
                        The <el>id</el> attribute is optional. It is an XML Infoset identifier that
                        identifies the XML Infoset associated with the input for use within the XPL
                        program. In particular, the XML Infoset may be referenced with the
                        <el>href</el> attribute on <el>p:input</el> elements within
                        <el>p:processor</el> elements.
                    </p>
                    <p>
                        If the <el>id</el> attribute is missing, the XPL program cannot read the
                        input. It may make sense to declare an XPL program input without reading it
                        so that external users of the XPL program are aware that the input may be
                        used in a future version of the program.
                    </p>
                </div3>
                <div3>
                    <head>The <el>p:output</el> element</head>
                    <pre>
&lt;p:output
    name = <emph>ncname</emph>
    href = <emph>infoset-reference</emph>
    schema-uri? = <emph>aaa</emph>
    schema-href? = <emph>aaa</emph> /&gt;
                    </pre>
                    <p>
                        The <el>p:output</el> element within a <el>p:pipeline</el> element defines
                        exactly one XPL program output. Zero, one or more <el>p:input</el> or
                        <el>p:output</el> elements can be children elements of the
                        <el>p:pipeline</el> element. They must occur before any other element in the
                        XPL program.
                    </p>
                    <p>
                        The <el>name</el> attribute is mandatory. It identifies the output to
                        external users of the XPL program. There cannot be two output with the same
                        name, but it is possible to have an output and an input with the same name.
                        It is a static error if two outputs have the same name.
                    </p>
                    <p>
                        The <el>href</el> attribute is mandatory. It identifies the XML Infoset that
                        must be produced by the XPL program in association with the output.
                    </p>
                    <p>
                        The Infoset reference contained by the <el>href</el> attribute may refer to
                        any XML Infoset identifier in scope after the last statement of the XPL program.
                        See <specref ref="infoset-reference"/> for the detailed syntax.
                    </p>
                </div3>
                <note>
                    The <el>p:input</el> and <el>p:output</el> elements can also be used within a
                    <el>p:processor</el> element. In that context, they support different
                    attributes and content.
                </note>
                <!--
                <div3>
                    <head>The <el>p:param</el> element</head>
                    <p>
                        <el>
                            &lt;p:param
                                name = <emph>aaa</emph>
                                type = <emph>aaa</emph> /&gt;
                        </el>
                    </p>
                    <p>
                        [TODO: it should be considered whether the <el>p:param</el> element should be
                        replaced by <el>p:input</el> and <el>p:output</el>.]
                    </p>
                    <p>
                        [TODO: it should be considered whether pipeline outputs should be referred to by
                        <el>href</el> / <el>id</el> attributes instead of the current <el>name</el>
                        <el>ref</el>. This would make the language more consistent.]
                    </p>
                    <p>
                        The <el>p:param</el> element defines exactly one XPL program input or
                        output. Zero, one or more <el>p:param</el> elements can be children elements
                        of the <el>p:pipeline</el> element. They must occur before any other
                        element in the XPL program.
                    </p>
                    <p>
                        The <el>type</el> attribute is mandatory and can have a value of either
                        <code>input</code> or <code>output</code>. A <el>p:param</el> element with a
                        value of <code>input</code> defines an XPL program input. A <el>p:param</el>
                        element with a value of <code>output</code> defines an XPL program output.
                    </p>
                    <p>
                        The <el>name</el> attribute is mandatory. There cannot be two inputs with the
                        same name or two outputs with the same name, but it is possible to have an
                        output and an input with the same name.
                    </p>
                    <p>
                        Every input name defines an XML Infoset identifier that may be later
                        referenced with the <el>href</el> attribute on <el>p:input</el> elements within
                        <el>p:processor</el> elements.
                    </p>
                    <p>
                        Every output name defines an identifier that must be referenced with the
                        <el>ref</el> attribute on <el>p:output</el> elements within
                        <el>p:processor</el> elements. There cannot be a <el>p:output</el> element
                        defining a name identical to an <el>id</el> attribute on a <el>p:output</el>
                        element within a <el>p:processor</el> element. The XPL implementation must
                        throw a static error if such a condition is encountered.
                    </p>
                </div3>
                -->
            </div2>
            <div2>
                <head>Processor Module</head>
                <div3>
                    <head>The <el>p:processor</el> element</head>
                    <pre>
&lt;p:processor
    name = <emph>qname</emph> &gt;
    &lt;!-- Content: (p:input* | p:output*) --&gt;
&lt;/p:processor&gt;
                    </pre>
                    <p>
                        The <el>p:processor</el> element declares a statement that consists of a
                        single XML processor instance.
                    </p>
                    <p>
                        The set of XML Infoset identifiers exposed by a <el>p:processor</el>
                        statement consists of the set of identifiers declared with the <el>id</el>
                        attribute on the nested <el>p:output</el> elements, if any.
                    </p>
                    <p>
                        The <el>name</el> attribute is mandatory. It is of type <termref
                        def="qname">QName</termref>. The QName identifies a particular XML
                        processor implementation. The prefix of the given QName must be in scope on
                        the <el>p:processor</el> element.
                    </p>
                    <p>
                        More than one <el>p:processor</el> elements with the same <el>name</el>
                        attribute may be used in an XPL program. This translates into using several
                        <termref def="xml-processor-instance">instances</termref> of the XML
                        processor.
                    </p>
                    <note>
                        The presence of a <el>p:processor</el> statement in an XML program does not
                        guarantee that the processor is executed. <specref ref="processing-model"/>
                        details the conditions under which a processor is executed.
                    </note>
                </div3>
                <div3>
                    <head>The <el>p:input</el> element</head>
                    <pre>
&lt;p:input
    name = <emph>ncname</emph>
    href? = <emph>infoset-reference</emph>
    schema-uri? = <emph>aaa</emph>
    schema-href? = <emph>aaa</emph> &gt;
    &lt;!-- Content: (embedded-infoset)? --&gt;
&lt;/p:input&gt;
                    </pre>
                    <p>
                        The <el>p:input</el> element connects an XML processor input identified by the
                        mandatory <el>name</el> attribute.
                    </p>
                    <p>
                        If the <el>href</el> attribute is missing, there must be an embedded Infoset as
                        a child of the <el>p:input</el> element. In that case, here must exactly one
                        child element of the <el>p:input</el> element. If no element is present or more
                        than one element is present, a static error must be raised. If the <el>href</el>
                        attribute is present and the <el>p:input</el> element has one or more children,
                        a static error must be raised.
                    </p>
                    <p>
                        The Infoset reference contained by the <el>href</el> attribute may refer to
                        any XML Infoset identifier in scope for the parent <el>p:processor</el>. See
                        <specref ref="infoset-reference"/> for the detailed syntax.
                    </p>
                    <p>
                        The optional <el>schema-href</el> and <el>schema-uri</el> refer to an external
                        schema. If both attributes are present, a static error must be raised.
                    </p>
                    <p>
                        If the <el>schema-href</el> attribute is present, it must contain a URL
                        referring to either an W3C XML Schema schema, or a Relax NG schema.
                    </p>
                    <p>
                        If the <el>schema-uri</el> attribute is present, it must contain a URI
                        identifying either an W3C XML Schema schema, or a Relax NG schema. The mapping
                        between the URI and the actual schema is outside the scope of the XPL
                        specification.
                    </p>
                    <p>
                        The use of <el>schema-href</el> allows easily using schemas bundled with an XPL
                        program. The use of <el>schema-uri</el> allows using URIs, commonly used with
                        XML Schema, which provide a level of abstraction hiding the actual storage
                        location of actual schema files.
                    </p>
                    <p>
                        If the XML Infoset read on the input does not validate against the schema
                        specified, a dynamic error is raised.
                    </p>
                    <note>
                        The XPL implementation is allowed to start providing parts of the XML
                        Infoset to the XML processor while validation is being performed. The
                        constraint is that the XML Infoset must be valid according to the schema up
                        to that point, and that when the XML processor has received the entire XML
                        Infoset, it is guaranteed to have received an XML Infoset valid according to
                        the provided schema. Such streamed validation may not be possible with all
                        schema languages.
                    </note>
                    <p>
                        For both attributes, it is a dynamic error if the schema cannot be loaded
                        during execution.
                    </p>
                    <p>
                        The embedded XML Infoset, if any, is constructed from the single element
                        under the <el>p:input</el> element as described in <specref
                        ref="infoset-extraction"/>.
                    </p>
                </div3>
                <div3>
                    <head>The <el>p:output</el> element</head>
                    <pre>
&lt;p:output
    name = <emph>ncname</emph>
    id = <emph>ncname</emph>
    schema-uri? = <emph>aaa</emph>
    schema-href? = <emph>aaa</emph> &gt;
&lt;/p:output&gt;
                    </pre>
                    <p>
                        The <el>p:output</el> element within a <el>p:processor</el> element
                        connects an XML processor output identified by the mandatory <el>name</el>
                        attribute.
                    </p>
                    <p>
                        Tne mandatory <el>id</el> element assigns an XML Infoset identifier with
                        the particular output.
                    </p>
                    <p>
                        The identifier must follow the no-collision rule. This means that the
                        identifier must not be present in the set of XML Infoset identifiers in
                        scope for the parent <el>p:processor</el> statement. The XPL implementation
                        must raise a static error if a collision is detected.
                    </p>
                    <p>
                        <el>p:output</el> supports the same <el>schema-href</el> and <el>schema-uri</el>
                        attributes present on the <el>p:input</el> element. If the XML Infoset produced
                        by the XML processor does not validate against the provided schema during
                        execution, a dynamic error is raised.
                    </p>
                    <note>
                        The XPL implementation is allowed to start receiving parts of the XML
                        Infoset from the XML processor while validation is being performed, and to
                        pass such parts to further XML processors consuming the XML Infoset. The
                        requirement is that the XML Infoset must be valid according to the schema up
                        to that point. Such streamed validation may not be possible with all schema
                        languages.
                    </note>
                </div3>
                <note>
                    The <el>p:input</el> and <el>p:output</el> elements can also be used within a
                    <el>p:processor</el> element. In that context, they support different
                    attributes and content.
                </note>
            </div2>
            <div2>
                <head>Choose Module</head>
                <div3>
                    <head>The <el>p:choose</el> element</head>
                    <pre>
&lt;p:choose
    href = <emph>infoset-reference</emph> &gt;
    &lt;!-- Content: (p:when*, p:otherwise?) --&gt;
&lt;/p:choose&gt;
                    </pre>
                    <p>
                        The <el>p:choose</el> element declares a statement used to execute different
                        sequences of statements depending on conditions evaluated during the
                        execution of the XPL program.
                    </p>
                    <p>
                        The content of a nested <el>p:when</el> or <el>p:otherwise</el> element is
                        called a <emph>branch</emph>. As detailed in the processing model section, a
                        branch may or may not be executed, and one branch of a <el>p:choose</el>
                        element at most is executed.
                    </p>
                    <p>
                        Conditions are expressed by children <el>p:when</el> elements using XPath
                        expresssions. They are applied to an XML Infoset determined by the
                        mandatory <el>href</el> attribute of the <el>p:choose</el> element.
                    </p>
                    <p>
                        The set of XML Infoset identifiers exposed by a <el>p:choose</el> statement
                        consists of the set of identifiers exported by all branches, as detailed
                        below.
                    </p>
                </div3>
                <div3>
                    <head>The <el>p:when</el> element</head>
                    <pre>
&lt;p:when
    test = <emph>expression</emph> &gt;
    &lt;!-- Content: (p:processor | p:choose | p:for-each)* --&gt;
&lt;/p:when&gt;
                    </pre>
                    <p>
                        A <el>p:when</el> element is always a child of a <el>p:choose</el> element.
                        A sequence of multiple <el>p:when</el> elements can be present under a
                        single <el>p:choose</el> element.
                    </p>
                    <p>
                        The mandatory <el>test</el> attribute contains an XPath expression. The result
                        of the expression must be castable to a boolean result. It is applied on the XML
                        Infoset provided to the parent <el>p:choose</el> element.
                    </p>
                    <p>
                        The <el>p:when</el> element may support <bibref ref="xpath-10"/> or <bibref
                        ref="xpath-20"/>. The details are specified in <specref
                        ref="conformance"/>.
                    </p>
                </div3>
                <div3>
                    <head>The <el>p:otherwise</el> element</head>
                    <pre>
&lt;p:otherwise&gt;
    &lt;!-- Content: (p:processor | p:choose | p:for-each)* --&gt;
&lt;/p:otherwise&gt;
                    </pre>
                    <p>
                        A <el>p:otherwise</el> element is always a child of a <el>p:choose</el>
                        element. If any <el>p:when</el> siblings are present, they must all precede
                        a <el>p:otherwise</el> element. There must be exactly zero or one
                        <el>p:otherwise</el> element child of a <el>p:choose</el> element.
                    </p>
                </div3>
                <div3>
                    <head>Branches</head>
                    <p>
                        Each <el>p:when</el> or <el>p:otherwise</el> branch may contain a sequence
                        of statements.
                    </p>
                    <p>
                        The set of scoped XML Infoset identifiers for the first statement in the
                        branch consists of the set of scoped identifiers for the parent
                        <el>p:choose</el> element.
                    </p>
                    <p>
                        The set of scoped XML Infoset identifiers after the last statement of a
                        branch are subject to the following conditions:
                    </p>
                    <ulist>
                        <item>
                            <p>
                                <emph>Consistency.</emph> The set of XML Infoset identifiers not
                                connected inside a branch must be consistent among all branches.
                                This means for example that if the first branch of a
                                <el>p:choose</el> element has two non-connected outputs identifiers
                                such as <code>output1</code> and <code>output2</code>, then all
                                other branches must export the same outputs identifiers.
                            </p>
                        </item>
                        <item>
                            <p>
                                <emph>Exposed XML Infoset identifiers.</emph> The set of XML
                                Infoset identifiers not connected inside a branch defines the set of
                                exposed identifiers for the <el>p:choose</el> statement.
                            </p>
                        </item>
                    </ulist>
                    <p>
                        A static error must be raised if any of those conditions is not met.
                    </p>
                    <note>
                        The no-collision rule applies for statements within a branch. In other words
                        an XML Infoset identifier exposed by a statement within a branch cannot
                        override an identifier scoped for the corresponding <el>p:choose</el>
                        element.
                    </note>
                </div3>
            </div2>
            <div2>
                <head>Repeat Module</head>
                <div3>
                    <head>The <el>p:for-each</el> element</head>
                    <pre>
&lt;p:for-each
    href = <emph>infoset-reference</emph>
    select = <emph>expression</emph>
    schema-href? <emph>aaa</emph>
    schema-uri? <emph>aaa</emph> &gt;
    &lt;!-- Content: (p:output?, (p:processor or p:choose or p:for-each)*) --&gt;
&lt;/p:for-each&gt;
                    </pre>
                    <p>
                        The <el>p:for-each</el> element declares a statement used to execute
                        sequences of statements multiple times within the execution of a same XPL
                        program.
                    </p>
                    <p>
                        The set of exposed XML Infoset identifiers consists of the single identifier
                        defined by the optional embedded <el>p:output</el> element's <el>id</el>
                        attribute. If there is no embedded <el>p:output</el> attribute, the set is
                        empty.
                    </p>
                    <p>
                        The <el>p:for-each</el> element contains a sequence of statements. If an
                        embedded <el>p:output</el> element is present, the sequence must
                        contain at least one statement. It is a static error if this is not the
                        case.
                    </p>
                    <p>
                        The set of scoped XML Infoset identifiers before the first statement in the
                        embedded sequence of statements consists of the identifiers scoped for the
                        <el>p:for-each</el> element.
                    </p>
                    <note>
                        The no-collision rule applies for statements within a <el>p:for-each</el>
                        element. In other words an XML Infoset identifier exposed within a
                        <el>p:for-each</el> cannot override an identifier scoped for corresponding
                        <el>p:for-each</el> element.
                    </note>
                </div3>
                <div3>
                    <head>The <el>p:output</el> element</head>
                    <pre>
&lt;p:output
    href = <emph>infoset-reference</emph>
    id = <emph>ncname</emph>
    schema-uri? = <emph>aaa</emph>
    schema-href? = <emph>aaa</emph> &gt;
&lt;/p:output&gt;
                    </pre>
                    <p>
                        The <el>p:output</el> element within a <el>p:for-each</el> element exposes
                        an XML Infoset identifier to statements appearing after the current
                        <el>p:for-each</el> statement.
                    </p>
                    <p>
                        Tne mandatory <el>id</el> element exposes an XML Infoset identifier. The
                        identifier must follow the no-collision rule. This means that the identifier
                        must not be present in the set of scoped XML Infoset identifiers for the
                        parent <el>p:for-each</el> statement. The XPL implementation must raise a
                        static error if a collision is detected.
                    </p>
                    <p>
                        The mandatory <el>href</el> attribute determines the XML infoset exposed.
                        The Infoset reference may refer to XML Infoset identifiers scoped on the
                        parent <el>p:for-each</el> element as well as to XML Infoset identifiers
                        scoped after the last statement of the sequence of statements embedded
                        within the <el>p:for-each</el> statement.
                    </p>
                    <p>
                        For the second category of XML Infoset identifiers, each identifier used by
                        the expression in the <el>href</el> attribute refers to a sequence of XML
                        Infosets rather than a single XML infoset as is usually the case. See
                        <specref ref="for-each-execution"/>.
                    </p>
                    <p>
                        [TODO: explain when schema validation raises errors]
                    </p>
                </div3>
                <div3>
                    <head>The <el>p:while</el> element</head>
                    <p>
                        [TODO: define?]
                    </p>
                </div3>
            </div2>
            <div2>
                <head>Exception Module</head>
                <div3>
                    <head>The <el>p:try</el> element</head>
                    <p>
                        [TODO: define?]
                    </p>
                </div3>
            </div2>
        </div1>
        <div1 id="processing-model">
            <head>Processing Model</head>
            <div2>
                <head>Introduction</head>
                <p>
                    The XPL processing model is based on declarative and lazy evaluation models.
                    This means that, unlike most imperative programming languages, processing order
                    is determined by first considering the results to be produced, and then walking
                    down a chain of dependencies to determine what statements must be executed. The
                    benefit of lazy evaluation and declarative programming is that they have more
                    potential for allowing implementations with different levels of optimization.
                </p>
            </div2>
            <div2>
                <head>Input Invariance</head>
                <p>
                    A processor, when given control, may read one or more of its inputs. The XPL
                    implementation must make sure that, if a processor reads the same input several
                    times over a single execution of a sequence of statements, the XML Infoset read
                    is the same.
                </p>
            </div2>
            <div2 id="output-invariance">
                <head>Output Invariance</head>
                <p>
                    Multiple statements may consume XML Infoset in a pipeline by referencing the
                    same XML Infoset identifier. These consumers may request the XML Infoset at
                    different times during pipeline execution. The XPL implementation must make sure
                    that the XML Infoset read by those different processors is the same for a given
                    execution of a sequence of statements.
                </p>
            </div2>
            <div2 id="connections">
                <head>Connections</head>
                <p>
                    A processor input with name <emph>n</emph> is said to be connected when:
                </p>
                <ulist>
                    <item>
                        <p>
                            The corresponding <el>p:processor</el> element contains an embedded
                            <el>p:input</el> element with an attribute <el>name</el> with value
                            <emph>n</emph>.
                        </p>
                    </item>
                    <item>
                        <p>
                            The <el>p:input</el> element contains an embedded XML Infoset, or has a
                            valid <el>href</el> attribute. See <specref ref="infoset-reference"/>.
                        </p>
                    </item>
                </ulist>
                <p>
                    A processor output with name <emph>n</emph> is said to be connected when:
                </p>
                <ulist>
                    <item>
                        It exposes an XML Infoset identifier <emph>i</emph>.
                    </item>
                    <item>
                        There exists an expression in the XPL program referring to <emph>i</emph>.
                    </item>
                </ulist>
            </div2>
            <div2>
                <head>XML Processor Execution</head>
                <p>
                    The execution of a processor always starts with an <emph>initialization
                    phase</emph>. During the initialization phase, the XML processor:
                </p>
                <ulist>
                    <item>
                        <p>
                            Is given control by the XPL implementation, through a mechanism outside
                            the scope of XPL.
                        </p>
                    </item>
                    <item>
                        <p>
                            Should reinitialize previous execution state if any.
                        </p>
                    </item>
                    <item>
                        <p>
                            May read one or more of its inputs, in any order and at any time.
                        </p>
                    </item>
                    <item>
                        <p>
                            May perform tasks unrelated to the XPL program, like interacting with
                            other software.
                        </p>
                    </item>
                    <item>
                        <p>
                            The processor should return control to the XPL implementation after a
                            finite amount of time. There may be some rare uses cases where not
                            returning control may be desirable.
                        </p>
                    </item>
                </ulist>
                <p>
                    If a processor does not have any connected output, the execution of the
                    processor terminates with the end of the initialization phase.
                </p>
                <p>
                    When a processor has at least one output, execution of the processor may resume
                    at a later point when the XML Infoset associated with an output is requested by
                    the XPL implementation. This is called a <emph>read phase</emph>. During such a
                    phase, the processor:
                </p>
                <ulist>
                    <item>
                        <p>
                            Is given control by the XPL implementation, through a mechanism outside
                            the scope of XPL.
                        </p>
                    </item>
                    <item>
                        <p>
                            May access execution state created during the initialization phase or
                            previous read phases, if necessary.
                        </p>
                    </item>
                    <item>
                        <p>
                            May read one or more of its inputs, in any order and at any time.
                        </p>
                    </item>
                    <item>
                        <p>
                            May perform tasks unrelated to the XPL program, like interacting with
                            other software.
                        </p>
                    </item>
                    <item>
                        <p>
                            The processor should return control to the XPL implementation after a
                            finite amount of time, and return an XML Infoset associated with that
                            output.. There may be some rare uses cases where not returning control
                            may be desirable.
                        </p>
                    </item>
                </ulist>
                <p>
                    There is no guarantee that an XML processor will read one or more of its inputs.
                    This is entirely left to the implementor of the XML processor.
                </p>
                <p>
                    There is no guarantee that a processor in a pipeline will be initialized, or
                    will have any read phase after an initialization phase. The only guarantee of
                    execution is that if an XML processor does not have any outputs and is declared
                    in a sequence of statements which is executed, then it will be initialized.
                </p>
            </div2>
            <div2>
                <head>Sequence of Statements Execution</head>
                <p>
                    The execution of a sequence of statements always starts with an <emph>initialization
                    phase</emph>. During the initialization phase:
                </p>
                <olist>
                    <item>
                        <p>
                            The sequence is <emph>initialized</emph>. The meaning of this is largely
                            implementation dependent, but may for example mean that execution state
                            information kept by the implementation and related to the execution of
                            this sequence of statements is discarded, for example, discarding XML
                            Infosets associated with some Infoset identifiers in the sequence. It
                            may also notifying processor instances that they should reinitialize
                            some internal state.
                        </p>
                    </item>
                    <item>
                        <p>
                            A list of statements in the sequence that do not have any connected output is
                            established in document order (in the order they appear in the XPL
                            program). Each statement in the list is then <emph>initialized</emph> in
                            that order.
                        </p>
                    </item>
                    <item>
                        <p>
                            During the initialization of an statement, that statement may read one
                            or more of its inputs. When doing so, control is passed to the XPL
                            implementation again. The XPL implementation must then obtain the XML
                            Infoset associated with that input, possibly by evaluating an
                            expression. That expression may refer to one or more XML Infoset
                            identifier. The XPL implementation must obtain those XML Infoset
                            identifiers in turn, by executing read phases on the statements exposing
                            those identifiers. When XML Infosets associated with all the XML Infoset
                            identifiers used by the expression are obtained, the XML Infoset
                            associated with the input is complete, and control is returned to the
                            statement.
                        </p>
                    </item>
                </olist>
                <p>
                    If the sequence of statements exposes XML Infoset identifiers, XML Infosets
                    associated with one or more of those identifiers may be requested by the XPL
                    implementation. When such an identifier <emph>i</emph> is requested, a
                    <emph>read phase</emph> is initiated on the sequence of statements:
                </p>
                <ulist>
                    <item>
                        <p>
                            The statement exposing the identifier <emph>i</emph> is initialized if and
                            only if not already done during the execution of the sequence of statements.
                        </p>
                    </item>
                    <item>
                        <p>
                            The XML Infoset associated with the XML Infoset identifier
                            <emph>i</emph> is requested from the statement by starting a read phase. The
                            XPL implementation may decide to store the XML Infoset to fulfill
                            further requests associated with <emph>i</emph>, and return the stored
                            XML Infoset when possible. How this is achieve is implementation
                            dependent, but in all cases output invariance must be guaranteed. See
                            <specref ref="output-invariance"/>.
                        </p>
                    </item>
                    <item>
                        <p>
                            Like during initialization, the statement may read one or more of its
                            inputs. The same processing model applies.
                        </p>
                    </item>
                    <item>
                        <p>
                            The XML Infoset associated with the XML Infoset identifier
                            <emph>i</emph> is forwarded to the requestor.
                        </p>
                    </item>
                </ulist>
            </div2>
            <div2>
                <head>XPL Program Execution</head>
                <p>
                    The execution of an XPL pipeline consists in executing the sequence of statements
                    contained under the <el>p:pipeline</el> element.
                </p>
                <p>
                    After the initialization phase, the XPL implementation may request XML Infosets
                    associated with pipeline outputs. To achieve this, <el>href</el> attribute
                    associated with the pipeline output to read is evaluated. This may cause
                    requesting one or more XML Infosets exposed by the sequence of statements,
                    therefore executing one or more read phases on the sequence of statements.
                </p>
            </div2>
            <div2>
                <head><el>p:choose</el> Execution</head>
                <p>
                    This section is relevant only if the Choose Module is implemented.
                </p>
                <p>
                    The execution of a <el>p:choose</el> statement consists in:
                </p>
                <ulist>
                    <item>
                        <p>
                            Obtaining the XML Infoset associated with the <el>p:choose</el>
                            element's <el>href</el> attribute. The expression is evaluated, and may
                            cause requesting one or more XML Infosets in scope.
                        </p>
                    </item>
                    <item>
                        <p>
                            For each <el>p:when</el> element contained in the <el>p:choose</el>
                            element, evaluate the expression contained in the <el>test</el>
                            attribute on the XML Infoset obtained previously. Evaluation must be
                            performed on <el>p:when</el> elements in document order. The result of
                            the expression is converted to an <code>xs:boolean</code> type. If this
                            is not possible, a dynamic error is generated. If the result of the
                            boolean expression is <code>true()</code>, the branch is selected.
                            Evaluation of further <el>p:when</el> elements must not be performed.
                        </p>
                    </item>
                    <item>
                        <p>
                            If the branches do not export any XML Infoset identifier, the selected
                            branch is considered a sequence of statements and is simply initialized.
                        </p>
                    </item>
                    <item>
                        <p>
                            If the branches export at least XML Infoset identifier, the selected
                            branch is considered a sequence of statements and is executed like a regular
                            sequence of statements.
                        </p>
                    </item>
                </ulist>
                <note>
                    Because of <specref ref="output-invariance"/>, when a branch is selected during
                    a particular execution, it remains selected for the rest of the execution. In
                    particular, if a branch exports several XML Infoset identifiers, and the
                    associated XML Infosets are requested, they are always requested from the same
                    branch.
                </note>
            </div2>
            <div2 id="for-each-execution">
                <head><el>p:for-each</el> Execution</head>
                <p>
                    This section is relevant only if the Repeat Module is implemented.
                </p>
                <p>
                    The execution of a <el>p:for-each</el> statement consists in:
                </p>
                <ulist>
                    <item>
                        <p>
                            Obtaining the XML Infoset associated with the <el>p:for-each</el>
                            element's <el>href</el> attribute. The expression is evaluated, and may
                            cause requesting one or more scoped XML Infosets.
                        </p>
                    </item>
                    <item>
                        <p>
                            Evaluating the expression on the <el>p:for-each</el> element's
                            <el>select</el> attribute. This expression must return a sequence of
                            elements called the <emph>iteration sequence</emph>. The iteration
                            sequence may be empty. If it does not consist of a sequence of elements,
                            a dynamic error must be raised. The iteration sequence may be calculated
                            lazily, and the dynamic error may be raised only when the first item in
                            the sequence that is not an element is found, if any.
                        </p>
                    </item>
                    <item>
                        <p>
                            If there is no nested <el>p:output</el> element, the embedded sequence
                            of statements is executed once for each element in the iteration
                            sequence. Because there is no read phase, this means that the sequence
                            of statements is initialized once for each element in the iteration
                            sequence. The function <el>current()</el> of <specref
                            ref="infoset-reference"/> is assigned a new XML Infoset built from the
                            current element of the iteration sequence. See <specref
                            ref="infoset-extraction"/>.
                        </p>
                    </item>
                    <item>
                        <p>
                            If there is a nested <el>p:output</el> element, the expression on the
                            <el>href</el> attribute of the embedded <el>p:output</el> element,
                            called the <emph>output expression</emph>, must be evaluated. It may
                            refer to XML Infoset identifiers of two types:
                        </p>
                        <ulist>
                            <p>
                                XML Infoset identifiers in scope for the <el>p:for-each</el>
                                statement. Those are called <emph>external XML Infoset
                                identifiers</emph>.
                            </p>
                            <p>
                                XML Infoset identifiers exposed by the sequence of statements
                                contained within the <el>p:for-each</el> statement. Those are called
                                <emph>local XML Infoset identifiers</emph>.
                            </p>
                        </ulist>
                        <p>
                            A local XML Infoset identifier must be interpreted as sequences of XML
                            Infosets. Each execution of the sequence of statements produces the
                            next value in the sequence. After initializing the embedded sequence of
                            statements, a read phase is performed for each such identifier, in the
                            order in which they appear in the output expression.
                        </p>
                        <p>
                            External XML Infoset identifiers refer to sequences of XML Infoset
                            identifiers that contain only one element.
                        </p>
                        <p>
                            When the embedded sequence of statements has been executed a number of
                            times equal to the number of elements in the iteration sequence, the
                            output expression must have produced a complete XML Infoset. That XML
                            Infoset is associated with the identifier on the <el>id</el> attribute
                            of the <el>p:output</el> element.
                        </p>
                    </item>
                    <item>
                        <p>
                            If there is a <el>p:output</el> element within the <el>p:for-each</el>
                            element but the iteration sequence is empty, the embedded sequence of
                            statements is never executed. The output expression is evaluated with
                            each local XML Infoset identifier replaced with an empty sequences.
                        </p>
                    </item>
                </ulist>
            </div2>
            <div2>
                <head><el>p:try</el> Execution</head>
                <p>
                    This section is relevant only if the Exception Module is implemented.
                </p>
                <p>
                    [TODO]
                </p>
            </div2>
        </div1>
        <div1 id="infoset-extraction">
            <head>Infoset Extraction</head>
            <p>
                XPL defines how an XML element <emph>el</emph> appearing anywhere in an XML Infoset
                (not necessarily as a document element) can be extracted to create a new XML Infoset
                with that element as document element.
            </p>
            <p>
                A new empty XML Infoset is created. The document information item created contains:
            </p>
            <ulist>
                <item>
                    <p>
                        A document element which contains the same information as <emph>el</emph>
                        except that: it does not have any parent element; it must contain new
                        namespace attributes information items for all the namespaces originally in
                        scope on the element but not declared on the element.
                    </p>
                </item>
                <item>
                    <p>
                        No processing instructions, comments, and document type declaration information.
                    </p>
                </item>
            </ulist>
        </div1>
        <div1 id="infoset-reference">
            <head>Infoset Reference</head>
            <p>
                Some attributes in XPL contain expressions called <emph>infoset references</emph>.
                Such expressions refer to or construct an XML Infoset and provide a way to:
            </p>
            <ulist>
                <item>
                    <p>
                        Reference external XML documents
                    </p>
                </item>
                <item>
                    <p>
                        Reference XML Infosets provided by processor outputs and pipeline inputs
                    </p>
                </item>
                <item>
                    <p>
                        Aggregate documents using the aggregate() function
                    </p>
                </item>
                <item>
                    <p>
                        Select part of a document using XPointer
                    </p>
                </item>
            </ulist>
            <p>
                The complete syntax of those expressions is described below in a Backus Nauer Form
                (BNF)-like syntax:
            </p>
            <pre>
href              ::= ( local_reference | uri_reference | aggregation | current ) [ xpointer ]
local_reference   ::= "#" id
aggregation       ::= "aggregate(" root_element_name "," agg_parameter ")"
current           ::= "current()"
root_element_name ::= "'"  name "'"
agg_parameter     ::= href [ "," agg_parameter ]
xpointer          ::= "#xpointer(" xpath_expression ")"
            </pre>
            <div2>
                <head>Local Reference</head>
                <p>
                    A local reference starts with the <code>#</code>sign and is followed by an XML
                    Infoset identifier. It refers to either a single XML Infoset, or a sequence of
                    XML Infosets. Whenever a local reference is used, it must refer to a scoped XML
                    Infoset identifier.
                </p>
                <p>
                    A local reference evaluates to the XML Infoset or XML Infoset sequence
                    identified by the XML Infoset identifier.
                </p>
                <note>
                    The only instance where a local reference evaluates to an XML Infoset sequence
                    instead of just one XML Infoset is within the <el>p:output</el> element
                    contained in a <el>p:for-each</el> statement.
                </note>
            </div2>
            <div2>
                <head>URI Reference</head>
                <p>
                    This definition is borrowed from <bibref ref="xslt-20"/>:
                </p>
                <termdef id="uri" term="URI Reference">
                    Within this specification, the term <term>URI Reference</term>, unless otherwise
                    stated, refers to a string in the lexical space of the <code>xs:anyURI</code>
                    data type as defined in <bibref ref="xml-schema"/>.
                </termdef>
                <p>
                    Note that this is a wider definition than the definition in <bibref
                    ref="rfc2396"/>, for example it does not require non-ASCII characters to be
                    escaped.
                </p>
<!--                <p>-->
<!--                    The rules for namespace URIs are given in <bibref ref="xml-namespaces-10"/> and-->
<!--                    <bibref ref="xml-namespaces-11"/>. Those specifications deprecate the use of-->
<!--                    relative URIs as namespace URIs.-->
<!--                </p>-->
                <p>
                    URI references used to identify external resources must conform to the same
                    rules as the locator attribute (<code>href</code>) defined in section 5.4 of
                    <bibref ref="xlink"/>. If the URI reference is relative, then it is resolved
                    (unless otherwise specified) against the base URI of the containing element
                    node, according to the rules of <bibref ref="rfc2396"/>, after first escaping
                    all characters that need to be escaped to make it a valid RFC2396 URI
                    reference.
                </p>
            </div2>
            <div2>
                <head>Aggregation</head>
                <p>
                    The <code>aggregate()</code> function takes as first argument a string
                    containing a QName. The QName determines the root element of a new XML Infoset.
                </p>
                <p>
                    The following arguments of the function can be of type <code>element()</code> or
                    <code>element()*</code> [TODO: solve conflict between notion of XML Infoset and
                    notion of root element of an XML Infoset]
                </p>
                <p>
                    The <code>aggregate()</code> functions evaluates to a new XML Infoset with root
                    element determined by the first argument. The root element has one child
                    elements per element passed to the function in the following arguments, in the
                    order they appear.
                </p>
            </div2>
            <div2>
                <head>Current XML Infoset</head>
                <p>
                    This section is relevant only if the Repeat Module is implemented.
                </p>
                <p>
                    The <code>current()</code> function evaluates to the current element of the
                    iteration sequence within a <el>p:for-each</el> statement.
                </p>
            </div2>
            <div2>
                <head>XPointer</head>
                <p>
                    [TODO]
                </p>
            </div2>
        </div1>
        <div1 id="standardprocessors">
            <head>Standard XML Processor Library</head>
            <div2>
                <head>Introduction</head>
                <p>
                    XPL defines a set of standard XML processors, called the XPL standard XML
                    processor library, that must be implemented by any conformant implementation.
                    All the XML processors are identified with a <termref
                    def="qname">QName</termref> with URI
                    <code>http://www.orbeon.com/oxf/pipeline</code>. The recommended namespace
                    prefix for that QName is <code>xpl</code>.
                </p>
            </div2>
            <div2>
                <head>Identity Processor</head>
                <div3>
                    <head>Interface</head>
                    <pre>
&lt;p:processor name="xpl:identity">
    &lt;p:input name="data">...&lt;/p:input>
    &lt;p:output name="data">...&lt;/p:output>
&lt;/p:processor&gt;
                    </pre>
                    <p>
                        The Identity processor is identified by a <termref
                        def="qname">QName</termref> with URI
                        <code>http://www.orbeon.com/oxf/pipeline</code> and local name
                        <code>identity</code>. It statically exposes an input called <el>data</el>
                        and an output called <el>data</el> as well.
                    </p>
                </div3>
                <div3>
                    <head>Behavior</head>
                    <p>
                        When a read phase is performed on the <el>data</el> output, the Identity
                        processor must return the XML Infoset available on the <el>data</el> input.
                        The Identity processor should obtain the XML infoset during the read phase
                        rather than during the initialization phase.
                    </p>
                </div3>
            </div2>
            <div2>
                <head>Pipeline Processor</head>
                <div3>
                    <head>Interface</head>
                    <pre>
&lt;p:processor name="xpl:pipeline">
    &lt;p:input name="pipeline">...&lt;/p:input>
&lt;/p:processor&gt;
                    </pre>
                    <p>
                        The Pipeline processor is identified by a <termref
                        def="qname">QName</termref> with URI
                        <code>http://www.orbeon.com/oxf/pipeline</code> and local name
                        <code>pipeline</code>. It statically exposes an input called
                        <el>pipeline</el>. It may also dynamically expose other inputs and outputs
                        as defined below.
                    </p>
                </div3>
                <div3>
                    <head>Behavior</head>
                    <p>
                        When initialized, the Pipeline processor instance must read its
                        <code>pipeline</code> input. The <code>pipeline</code> input must contain an
                        XPL program <emph>p</emph> conforming to this specification. If
                        <emph>p</emph> doesn't conform to this specification, the Pipeline processor
                        must raise a dynamic error.
                    </p>
                    <p>
                        <emph>p</emph> must not have an input called <code>pipeline</code>. If it
                        does, the Pipeline processor must raise a dynamic error.
                    </p>
                    <p>
                        The Pipeline processor must connect the inputs of <emph>p</emph> to it's
                        own inputs with the same names, as follows. For each input <emph>i</emph>
                        of <emph>p</emph> with name <code>n</code>:
                    </p>
                    <ulist>
                        <item>
                            <p>If the Pipeline processor instance has a connected input
                            <emph>j</emph> with name <code>n</code>, connect input <emph>i</emph> to
                            <emph>j</emph>.</p>
                        </item>
                        <item>
                            <p>If the Pipeline processor instance does not have such a connected
                            input, do nothing.</p>
                        </item>
                    </ulist>
                    <p>
                        Connecting two inputs here means that when the Pipeline processor instance
                        executes <emph>p</emph>, and <emph>p</emph> requests the XML Infoset
                        associated with its input <emph>i</emph>, the Pipeline processor instance
                        must obtain the XML Infoset provided to it on its input <emph>j</emph> and
                        forward it to <emph>p</emph> unmodified.
                    </p>
                    <p>
                        If the Pipeline processor instance executes <emph>p</emph> and
                        <emph>p</emph> requests an XML Infoset associated with an input
                        <emph>i</emph> with name <code>n</code> and the Pipeline processor instance
                        does not have an input <emph>j</emph> with name <code>n</code>, the Pipeline
                        processor must throw a dynamic error.
                    </p>
                     <p>
                        The Pipeline processor must connect its own outputs to <emph>p</emph>'s
                        outputs with the same name, as follows. For each of its connected output
                        <emph>o</emph> with name <code>m</code>:
                    </p>
                    <ulist>
                        <item>
                            <p>If <emph>p</emph> has an output <emph>q</emph> with name
                            <code>m</code>, connect output <emph>o</emph> to <emph>q</emph>.</p>
                        </item>
                        <item>
                            <p>If <emph>p</emph> does not have such an output, raise a dynamic
                            error.</p>
                        </item>
                    </ulist>
                    <p>
                        Connecting two outputs here means that when the Pipeline processor instance
                        is requesting the XML Infoset associated with its output <emph>o</emph> with
                        name <code>m</code>, the Pipeline processor instance must obtain the XML
                        Infoset provided by <emph>p</emph> on its output <emph>q</emph> with name
                        <code>m</code>.
                    </p>
                    <p>
                        When a read phase is started by the XPL implementation on one of the
                        Pipeline processor output <emph>o</emph> with name <code>m</code>, if it has
                        any, the Pipeline processor must execute a read phase on the XPL program's
                        output <emph>q</emph> with name <code>m</code>.
                    </p>
                </div3>
            </div2>
            <div2>
                <head>Null Serializer</head>
                <div3>
                    <head>Interface</head>
                    <pre>
&lt;p:processor name="xpl:null-serializer">
    &lt;p:input name="data">...&lt;/p:input>
&lt;/p:processor&gt;
                    </pre>
                    <p>
                        The Null Serializer processor is identified by a <termref
                        def="qname">QName</termref> with URI
                        <code>http://www.orbeon.com/oxf/pipeline</code> and local name
                        <code>null-serializer</code>. It statically exposes an input called
                        <el>data</el>.
                    </p>
                </div3>
                <div3>
                    <head>Behavior</head>
                    <p>
                        When initialized, the Null Serializer processor reads the XML Infoset
                        associated with its <code>data</code> input. It then discards it without
                        further processing.
                    </p>
                    <note>
                        Here "discarding" means that the XML Infoset is no longer required by the
                        XPL implementation. XPL implementations may however use the XML Infoset
                        read for debugging or logging purposes, for example.
                    </note>
                </div3>
            </div2>
        </div1>
        <div1 id="inclusions">
            <head>Inclusions</head>
            <p>
                XPL does not have any particular construct for inclusions or imports. However, a
                compliant XPL implementation must support at least a subset of the XInclude 1.0
                specification. Namely, the <el>xi:include</el> elements with the <el>parse</el>
                attribute either missing or set to <code>xml</code>, and without any other
                attributes. It may support more of the XInclude 1.0 specification. XPL does not
                specify what schemes are supported by the <el>href</el> attribute.
            </p>
            <p>
                <el>xi:include</el> elements may appear at any point in an XPL program allowed by
                the XInclude 1.0 specification.
            </p>
        </div1>
        <div1 id="conformance">
            <head>Conformance</head>
            <p>
                A conformant XPL implementation must at least implement the Basic XPL Profile
                described below. Implementors are however encouraged to implement the optional
                modules. A conformant implementation must document what modules it implements.
            </p>
            <div2>
                <head>Basic Profile</head>
                <p>
                    The Basic XPL profile requires implementing all of this specification except the
                    optional Choose, Repeat and Exception modules. The Pipeline and Processor
                    modules must be implemented.
                </p>
            </div2>
            <div2>
                <head>Full Profile</head>
                <p>
                    The full XPL profile requires implementing all of this specification including
                    the Pipeline, Processor, Choose, Repeat and Exception modules.
                </p>
            </div2>
            <div2>
                <head>XPath Support</head>
                <p>
                    XPL constructs using XPath my support the following version of XPath:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>XPath 1.0.</emph> In this case, <bibref ref="xpath-10"/> must be
                            supported in the <el>test</el> attribute of the <el>p:when</el> element.
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>XPath 2.0.</emph> In this case, <bibref ref="xpath-20"/> must be
                            supported in the <el>test</el> attribute of the <el>p:when</el> element.
                        </p>
                    </item>
                </ulist>
                <p>
                    An XPL implementation must document the version of XPath used. It may
                    optionally allow users to configure which XPath version must be used when
                    executing a pipeline. XPL itself does not have any provisions to configure,
                    whether on a XPL program basis, or on a finer granularity basis, what version of
                    XPath is used.
                </p>
                <p>
                    An <bibref ref="xpath-20"/> expression must raise a dynamic error if encountered
                    by an XPL implementation supporting only <bibref ref="xpath-10"/>. Optionally,
                    the XPL implementation may raise a static error if it is able to detect the
                    error before execution.
                </p>
            </div2>
        </div1>
    </body>
    <back>
        <div1 id="references">
            <head>References</head>
            <div2 id="references">
                <head>Normative References</head>
                <blist>
                    <bibl id="xml-infoset" href="http://www.w3.org/TR/xml-infoset/" key="XML Infoset" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Richard Tobin and John Cowan, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Information Set</titleref>.
                        World Wide Web Consortium, 2001.
                    </bibl>
                    <bibl id="xml-10" href="http://www.w3.org/TR/2000/REC-xml-20001006" key="XML 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Extensible Markup Language (XML) 1.0 (Second Edition)</titleref>.
                        World Wide Web Consortium, 2000.
                    </bibl>
                    <bibl id="xml-11" href="http://www.w3.org/TR/xml11/" key="XML 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Tim Bray, Jean Paoli, C. M. Sperberg-McQueen, Eve Maler, François Yergeau, John Cowan, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Extensible Markup Language (XML) 1.1</titleref>.
                        World Wide Web Consortium, 2004.
                    </bibl>
                    <bibl id="xml-base" href="http://www.w3.org/TR/xmlbase/" key="XML Base" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Jonathan Marsh, editor.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Base</titleref>.
                        World Wide Web Consortium, 2000.
                    </bibl>
                    <bibl id="xml-namespaces-10" href="http://www.w3.org/TR/REC-xml-names/" key="XML Namespaces 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Tim Bray, Dave Hollander, Andrew Layman, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Namespaces in XML</titleref>.
                        World Wide Web Consortium, 1999.
                    </bibl>
                    <bibl id="xml-namespaces-11" href="http://www.w3.org/TR/2004/REC-xml-names11-20040204/" key="XML Namespaces 1.1" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Tim Bray, Dave Hollander, Andrew Layman, Richard Tobin, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Linking Language (XLink) Version 1.0</titleref>.
                        World Wide Web Consortium, 2004.
                    </bibl>
                    <bibl id="xml-schema" href="http://www.w3.org/TR/xmlschema-1/" key="XML Schema" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Henry S. Thompson, David Beech, Murray Maloney, et al. editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Schema Part 1: Structures</titleref>.
                        World Wide Web Consortium, 2000.
                    </bibl>
                    <bibl id="xlink" href="http://www.w3.org/TR/xlink/" key="XLink" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Steve DeRose, Eve Maler, David Orchard, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Linking Language (XLink) Version 1.0</titleref>.
                        World Wide Web Consortium, 2001.
                    </bibl>

                    <bibl id="xpointer" href="http://www.w3.org/TR/xptr-framework/" key="XPointer Framework" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Paul Grosso, Eve Maler, Jonathan Marsh, Norman Walsh, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XPointer Framework</titleref>.
                        World Wide Web Consortium, 2003.
                    </bibl>
                    <bibl id="xpath-10" href="http://www.w3.org/TR/xpath.html" key="XPath 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        James Clark, Steve DeRose, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        XML Path Language (XPath) 1.0</titleref>. World Wide Web Consortium, 1999.
                    </bibl>
                    <bibl id="xpath-20" href="http://www.w3.org/TR/2004/WD-xpath20-20041029/" key="XPath 2.0 Working Draft" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Anders Berglund, Scott Boag, Don Chamberlin, Mary F. Fernández, Michael Kay, Jonathan Robie, Jérôme Siméon, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        XML Path Language (XPath) 2.0 Working Draft</titleref>. World Wide Web Consortium, 2004.
                    </bibl>
                    <bibl id="relax-ng" href="http://www.oasis- open.org/committees/relax- ng/" key="RELAX NG" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        James Clark, editor.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">OASIS RELAX NG Technical Committee</titleref>.
                        OASIS. 2001.
                    </bibl>
                    <bibl id="rfc2119" href="http://www.ietf.org/rfc/rfc2119.txt" key="RFC 2119" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        S. Bradner, editor.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Key words for use in RFCs to Indicate Requirement Levels</titleref>.
                        IETF (Internet Engineering Task Force), March 1997.
                    </bibl>
                    <bibl id="xinclude" href="http://www.w3.org/TR/xinclude/" key="XInclude" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Jonathan Marsh and David Orchard, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XML Inclusions (XInclude) Version 1.0</titleref>.
                        World Wide Web Consortium, 2001.
                    </bibl>
                </blist>
            </div2>
            <div2>
                <head>Other References</head>
                <blist>
                    <bibl id="rfc2396" href="http://www.ietf.org/rfc/rfc2396.txt" key="RFC2396" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        T. Berners-Lee, R. Fielding, L. Masinter, editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">Uniform Resource Identifiers (URI): Generic Syntax. IETF RFC 2396</titleref>.
                    </bibl>
                    <bibl id="xquery-10" href="http://www.w3.org/TR/xquery/" key="XQuery" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Don Chamberlin, James Clark, Daniela Florescu, et al., editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">XQuery 1.0: An XML Query Language</titleref>.
                        World Wide Web Consortium, 2001.
                    </bibl>
                    <bibl id="xslt-10" href="http://www.w3.org/TR/xslt" key="XSLT 1.0" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        James Clark, editor.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        XSL Transformations (XSLT) Version 1.0</titleref>. World Wide Web Consortium, 1999.
                    </bibl>
                    <bibl id="xslt-20" href="http://www.w3.org/TR/2004/WD-xslt20-20041105/" key="XSLT 2.0 Working Draft" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Michael Kay, editor.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        XSL Transformations (XSLT) Version 2.0 Working Draft</titleref>. World Wide Web Consortium, 2004.
                    </bibl>
                    <bibl id="xml-pipeline-definition" href="http://www.w3.org/TR/2002/NOTE-xml-pipeline-20020228/" key="XML Pipeline Definition Language" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Norman Walsh, Eve Maler editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        XML Pipeline Definition Language Version 1.0</titleref>. World Wide Web Consortium, 2002.
                    </bibl>
                    <bibl id="xml-processing" href="http://www.w3.org/TR/2004/NOTE-proc-model-req-20040405/NOTE-proc-model-req-20040405.xml" key="XML Processing Model" xlink:type="simple" xlink:show="replace" xlink:actuate="onRequest">
                        Dmitry Lenkov, Norman Walsh editors.
                        <titleref xlink:type="simple" xlink:show="new" xlink:actuate="onRequest">
                        XML Processing Model Requirements</titleref>. World Wide Web Consortium, 2004.
                    </bibl>
                </blist>
            </div2>
        </div1>
        <div1 id="examples">
            <head>Examples and Use Cases (Non-Normative)</head>
            <div2>
                <head></head>
                <p>
                    [TODO]
                </p>
            </div2>
        </div1>
        <div1 id="relationship">
            <head> Relationship with Other Specifications (Non-Normative)</head>
            <p>
                This section discusses the relationship of XPL with other relevant specifications.
                It is not normative, but is there to acknowledge that those specifications were
                taken into account and to highlight similarities and differences.
            </p>
            <div2>
                <head>February 2002 XML Pipeline Definition Language W3C Note</head>
                <p>
                    Work on XPL started in 2002 independently from <bibref
                    ref="xml-pipeline-definition"/>, a W3C Note published in February 2002. The
                    similarities between XPL and the W3C Note may appear startling. This is easily
                    explained by the fact that both initiatives aimed at solving a similar problem.
                    The similarities however remain mostly at the surface. XPL has a different
                    processing model, and proposes constructs different from those of the W3C Note.
                </p>
                <p>
                    XPL does:
                </p>
                <ulist>
                    <item><p>Define an XML pipeline language</p></item>
                    <item><p>Describe the equivalent of "processes"</p></item>
                </ulist>
                <p>
                    The basics of XPL are arguably simpler than the W3C Note:
                </p>
                <ulist>
                    <item>
                        <p>
                            XPL does not follow a "build system" approach with concepts such as
                            "targets" being "up to date". Rather, an XPL pipeline is executed, and
                            may return zero, one or more XML Infosets. This approach is closer from
                            the approach followed by most programming languages. Further, it is
                            thought that the concept of target is not necessary: choosing two
                            different targets can be reduced to choosing two different pipelines.
                        </p>
                    </item>
                    <item>
                        <p>
                            XPL remains declarative, in that the products of the execution of a
                            pipeline determines the processing order.
                        </p>
                    </item>
                    <item>
                        <p>
                            XPL does not allow for elements from foreign vocabularies except as a
                            convenience in the particular case of embedded processor input Infosets.
                        </p>
                    </item>
                    <item>
                        <p>
                            XPL does not specify how "processes" ("processors" in the XPL
                            terminology) are defined (W3C Note's process definitions). Such
                            definitions are outside the scope of XPL and left to language
                            implementors. The only assumption is that processors are declared and
                            that they expose an XML qualified name (QName) that identifies them.
                        </p>
                    </item>
                    <item>
                        <p>
                            XPL processors only support inputs and outputs that are XML Infosets.
                            There is no concept of additional parameters (W3C Note
                            <el>p:param</el>) to pass to processors. The rationale for this
                            decision is that it is always possible to pass such parameters in the
                            form of an XML Infoset.
                        </p>
                    </item>
                    <item>
                        <p>
                        XPL does not limit the types of Infosets produced by processors.
                        </p>
                    </item>
                    <item>
                        <p>
                            XPL pipelines either entirely succeed or entirely fail (basic profile).
                            When exception handling is added (exception module), exceptions are
                            handled acccordingly.
                        </p>
                    </item>
                    <item>
                        <p>
                        There is no "p:document" element. Instead, a particular processor, such as
                        the identity processor, can be used for the same purpose.
                        </p>
                    </item>
                </ulist>
            </div2>
            <div2>
                <head>April 2004 XML Processing Model W3C Note</head>
                <p>
                    <bibref ref="xml-processing"/>, a W3C Note published in April 2004, sets forth
                    a number of requirements for an XML processing model. XPL hopes to answer all
                    those requirements:
                </p>
                <ulist>
                    <item>
                        <p>
                            <emph>The language must be rich enough to address practical
                            interoperability concerns.</emph> To achieve this goal, the language
                            cannot be simplistic and needs to implement a number of basic features.
                            The XPL specification defines a basic profile, and a nunmber of modules
                            that can be optionally implemented. [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The language should be as small and simple as possible.</emph> XPL
                            supports a fairly small set of reatures and the basic concepts remain
                            simple. Whenever possible, existing specifications are leveraged (XPath,
                            for example). In addition XPL, like XSLT before it, may be written by
                            hand, so the language should be reasonably concise. The notion of
                            modules allows implementors to start small and then add more advanced
                            features. [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The language must allow the inputs, outputs, and other parameters
                            of a components to be specified.</emph> In this specification, the
                            language only uses XML Infosets to pass inputs and parameters to as
                            component. It is thought that this makes XPL simpler. Our interpretation
                            is that this is compatible with the requirement. [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The language must define the basic minimal set of mandatory input
                            processing options and associated error reporting options required to
                            achieve interoperability.</emph> Currently, XPL does not have any
                            error handling facilities. It is thought that the best way of achieving
                            this is to implement exception handling. [NO, YES soon]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Given a set of components and a set of documents, the language
                            must allow the order of processing to be specified.</emph> XPL
                            determines an implicit execution order. The order is predictable up to a
                            certain level. Additional constraints would make the language more
                            complex, but if needed, could be added. [?]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>It should be relatively easy to implement a conformant
                            implementation of the language, but it should also be possible to build
                            a sophisticated implementation that can perform parallel operations,
                            lazy or greedy processing, and other optimizations.</emph> [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model should be extensible enough so that applications can
                            define new processes and make them a component in a pipeline.</emph>
                            [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model must provide mechanisms for addressing error handling
                            and fallback behaviors.</emph> [SEE ERROR REPORTING ABOVE]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model could allow conditional processing so that different
                            components are selected depending on run-time evaluation.</emph> [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model should not prohibit the existence of streaming
                            pipelines.</emph> [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model should allow multiple inputs and multiple outputs for a
                            component.</emph> [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model should allow any data set conforming to one of the W3C
                            standards, such as XML 1.1, XSLT 1.0, XML Query 1.0, etc., to be
                            specified as an input or output of a component.</emph> How this should
                            be interpreted is not clear. Limiting inputs and outputs to Infosets
                            makes the language simpler, while still not prohibiting passing non-XML
                            Infoset data by encapsulating it within an XML Infoset, be it a simple
                            root element containing character data. [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>Information should be passed between components in a standard way,
                            for example, as one of the data sets conforming to an industry
                            standard.</emph> This is not a clear requirement. Each component
                            defines the Infosets it produces and generates, and it should not be up
                            to the pipeline language to define what they are. However, XPL supports
                            inline validation able to enforce such constraints. [YES?]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The language should be expressed in XML.</emph> [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The pipeline language should be declarative, not based on
                            APIs.</emph> [YES]
                        </p>
                    </item>
                    <item>
                        <p>
                            <emph>The model should be neutral with respect to implementation
                            language.</emph> [YES]
                        </p>
                    </item>
                </ulist>
                <p>
                    It should be noted that XPL provides more than the minimal requirements above,
                    and that in addition, the use cases of that Note can all be satisfied by XPL.
                </p>
            </div2>
            <div2>
                <head>WS-BPEL 2.0</head>
                <p>
                    [TODO]
                </p>
            </div2>
            <div2>
                <head>SXPipe</head>
                <p>
                    [TODO]
                </p>
            </div2>
        </div1>
        <div1>
            <head>Schema for XPL</head>
            <p>
                This appendix provides a W3C XML Schema for XPL.
            </p>
            <p>
                [TODO]
            </p>
        </div1>
        <div1>
            <head>Summary of Issues (Non-Normative)</head>
            <div2>
                <head>Open Issues</head>
                <p>
                    This appendix identifies open issues with this specification:
                </p>
                <olist>
                    <item>
                        <p>
                            Determine if terminology of "step" is appropriate. [REPLACED STEPS BY STATEMENTS]
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine company-agnostic namespace for XPL.
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine whether p:config is to be renamed. [YES, DONE]
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine whether p:param are to be renamed and based on new use of
                            p:input and p:output. Benefits: [PROPOSAL STILL NEEDS TO BE
                            EXAMINED, BUT DONE IN THIS VERSION]
                        </p>
                        <ulist>
                            <item>
                                One less element name in the vocabulary.
                            </item>
                            <item>
                                Brings consistency. An input always refers to something with an "id"
                                as opposed to sometimes and "id" and sometimes a "name". An output
                                always declare an "id" as opposed to declaring an "id" and sometimes
                                a "ref".
                            </item>
                            <item>
                                No confusion between href and ref.
                            </item>
                            <item>
                                Pipeline outputs behave like regular processor inputs.
                            </item>
                            <item>
                                Still covers all possible scenarios covered before, and more.
                            </item>
                            <item>
                                Allows dissociating pipeline input and output names from internal ids.
                            </item>
                            <item>
                                Allows using all the syntax of href on pipeline outputs.
                            </item>
                        </ulist>
                        <p>
                            Potential drawbacks:
                        </p>
                        <ulist>
                            <item>
                                Output href will refer to ids that are not yet visible. Does this
                                violate something we care about? Practically, you can easily keep in
                                memory the list of outputs and process them at the end of the
                                pipeline.
                            </item>
                        </ulist>
                        <note>
                            Requires also to change p:for-each, if it is allowed to use a "ref"
                            attribute. This is a big unknown for the moment: can we come up with a
                            nice, light syntax consistent with the rest?
                        </note>
                    </item>
                    <item>
                        <p>
                            Determine wither p:pipeline/p:output should support embedded XML Infoset
                            like p:input.
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine whether p:while must be defined in XPL 1.0.
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine whether exception handling must be defined in XPL 1.0.
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine whether unconnected outputs are allowed.
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine whether a p:choose with only a p:otherwise is allowed.
                        </p>
                    </item>
                    <item>
                        <p>
                            Determine how to solve issue of exporting ids from p:choose branches.
                            Should we use an attribute, or simply the p:output syntax? What about
                            p:for-each, could it also use p:output? Although in this case, the
                            processor itself does some aggregation work, so the semantic of p:output
                            would probably be stretched.
                        </p>
                    </item>
                    <item>
                        <p>
                            Debug attributes are currently not specified. Are we happy with this
                            solution?
                        </p>
                    </item>
                    <item>
                        <p>
                            Do we actually support officially multiple processor inputs or outputs
                            with the same name? In Presentation Server, this is used internally for
                            teeing, but do we actually have any documented processor with this
                            feature? It would definitely make things easier if we did not have to
                            support this.
                        </p>
                    </item>
                </olist>
            </div2>
        </div1>
    </back>
</spec>

<!--

TODO:
    o threading: mention?
    o debug attribute: proc, choose, for-each
    o schemas on p:param [now p:output / p:input]: group explanation in central location
    o improve [Relationship with the W3C Note 28 February 2002]
    o Refer to ncname definition: http://www.w3.org/TR/REC-xml-names/#NT-NCName
    o mention sub-pipelines (in xpl:pipeline?)
    o check XPath 2.0 spec and "host language"
    o current() for p:for-each
    o improve "no-collision rule"
    o p:choose: export of identifiers

-->
